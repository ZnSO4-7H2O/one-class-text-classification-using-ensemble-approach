{"title": "Modeling Biological Problems in Computer Science: A Case Study in Genome  Assembly", "tag": "q-bio", "abstract": " As computer scientists working in bioinformatics/computational biology, we often face the challenge of coming up with an algorithm to answer a biological question. This occurs in many areas, such as variant calling, alignment, and assembly. In this tutorial, we use the example of the genome assembly problem to demonstrate how to go from a question in the biological realm to a solution in the computer science realm. We show the modeling process step-by-step, including all the intermediate failed attempts. ", "text": "formatics/computational biology often face challenge coming algorithm answer biological question. occurs many areas variant calling alignment assembly. tutorial example genome assembly problem demonstrate question biological realm solution computer science realm. show modeling process step-by-step including intermediate failed attempts. first must understand biological question. must rely biologist explain simpliﬁed understand. happen directly communication biologist happen indirectly reading articles biological journals. begin hypothetical description might provided problem inside nucleus every cell molecules altogether called genome. molecule chain composed smaller elements called nucleotides four nucleotides cytosine guanine adenine thymine biologists interested knowing sequence chain unfortunately technology could report full sequence. called sequencing technology works follows. extracted cell ampliﬁed fragmented smaller pieces initial sequence smaller piece determined machine outputs collection short sequences called reads. number reads length varies speciﬁc technology experiment. typical scenario million reads length genome length million nucleotides. given collection reads biologist would like know full sequence genome. loosely referred problem genome assembly. biologist would immediately point calling description simpliﬁcation euphemism. fact types simpliﬁcations description. ﬁrst factual inaccuracies. example molecule chain composed nucleotides fact chains nucleotides chain watson-crick complement other. another example ampliﬁcation process perfect occasionally create molecules originally occur cell. second type simpliﬁcation omission important information. example left fact molecule actually structure structure inﬂuence fragmentation happens. another omission machine output quality values nucleotide representing probability error. addition intentional simpliﬁcations also unknown factors cannot captured problem description. example technician performing experiment made mistake experimental protocol resulting unpredictable eﬀects. simpliﬁcations unavoidable. computer scientists would time-prohibitive understand details sequencing process. describing problem computer scientist biologist must implicitly decide details relevant omit ones thinks not. even biologist wants describe every single detail details chemical level even fully grasp. even also expert chemistry would details level physics would grasp. fundamentally biological data generation process described words words deﬁnition simpliﬁcation reality. even propose perfect solution biological problem understood could still failure applied real data. hence must never conﬁdent correctness solution propose stated biological problem. keeping caveat mind solution. might tempting immediately start designing algorithm solve problem computer science best providing solutions problems stated certain mathematical rigor. description problem mathematical level would allow harness power computer science. therefore must ﬁrst formulate problem stated language computer science call problem well-formulated. lists principles well-formulated problem. make ﬁrst attempt formulation. here made explicit input output requirements problem. also replaced imprecise notion short sequence used describe read problem precise formality string. nevertheless problem falls short well-formulated numerous reasons. useful sanity check detect formulation imagine giving another computer scientist withgiving biological background. would able solve idea terms sequencing experiment generated genome mean. words problem self-contained. again. made improvements longer referring mathematically undeﬁned terms. fail another sanity check. formulation must implicitly deﬁne check output program solves correct. example could unknown string called genome perhaps genome aacgg. problem ambiguous regard give verify whether algorithm correct. undeterred formulation follows diﬀerence formulation subtle important. makes reference unknown genome. instead states clearly output correct common superstring. thus aacgg cggaac correct solutions. fact ﬁnally well-formulated problem fact reads errors. read error longer substring genome. already argued simpliﬁcations problem inevitable. simpliﬁcation problem choice clear solution problem work real data. create simpliﬁcation then? hope simple formulation even inaccurate lead algorithm useful practice. generally speaking formulation useful leads algorithm eﬃcient accurate applied real data. making model accurate would also make complicated representing trade-oﬀ. hand formulation simple risks leading algorithm useful practice. hand formulation realistic risks making impossible solve problem. know draw line then? simple rule part research challenge. faced situations like this computer scientists three choices simpliﬁed formulation hope inaccuracy aﬀect accuracy algorithm real data. words hope solution problem formulation work well applied real data regardless simpliﬁcations. make formulation complex removing unrealistic assumptions. case would include possibility errors loosening superstring requirement problem allow mismatches. going option hope still come eﬃcient algorithm spite model’s complexity. case could formulate problems instead one. ﬁrst would take erroneous reads correct them second would take corrected reads common superstring second formulation makes simplifying assumption ﬁrst designed ensure assumption holds. modularization potential avoid complex formulations avoiding simplifying assumptions. however often possible transform data simplifying assumption holds. knowing option choose rather science. correct choice often arrived trial-and-error involves extensive experiments simulated real data. discuss thoroughly section meanwhile problem chosen ﬁrst option though leave open possibility later switch option three necessary. solving problem must keep mind algorithm likely live inside bioinformatics pipeline. upstream downstream algorithms introduce errors data stream algorithms within pipeline must robust presence errors. beneﬁts algorithm perfectly solves formulation often nulliﬁed becomes part pipeline problem formulation never capture sources errors errors anyway introduced downstream algorithms. ultimate test algorithm performs real data opposed provable properties respect problem formulation. useful unlikely genome generated reads. observe many solutions. example could concatenate strings order want. concatenation would equally valid solution formulation. fact inﬁnitely many solutions concatenate solution itself still valid solution. makes unlikely pick arbitrary correct biological one. problem well-formulated useful. issue problem many solutions attempt distinguish better another. need instead optimization problem. optimization problem feasible solutions function gives cost score feasible solution. optimal solution feasible solution lowest cost highest score. acgtttttcgt common superstrings. intuitively though would probably pick acgt best solution shortest. intuition reﬂects parsimony principle states simplest explanation correct one. reformulate problem follows notice optimization problem cost function length feasible solution. looking example optimal solution fact acgt unique. great general case desired property limited number optimal solutions? answer immediately obvious revisit section readers unfamiliar computational complexity considered useful separate problems polynomial-time algorithm algorithm known. ﬁrst class problems said tractable. np-hard problems type problem formulated problem eﬃciently solved using well-known techniques. relationship well-studied theoretical problems? case problem well-studied computer science problem called shortest common superstring problem. computational complexity turns known; np-hard meaning unlikely exact polynomial-time algorithm exists. necessarily make problem formulation bad. whole books describing available techniques solve np-hard problems. example size input small enough allow asymptotically slow exact algorithm. perhaps worst-case inputs occur practice heuristic algorithm work well real instances. course ideally could formulation tractable might still achieved remove constraints deﬁnition. section simplifying assumptions thereby removing constraints make problem tractable. adding constraints also eﬀect. case problem ignores fact clearly stated problem strings alphabet size could problem tractable restriction added? unfortunately quick internet search reveals problem np-hard even alphabet binary. putting aside issue computational complexity back ourselves someone gave black-box algorithm problem would output fact reconstruct genome answer need test solution problem dataset know answer. take known genome sequence e.g. inﬂuenza virus idealized simulation sequencing process. take substrings length every position genome. next need implement algorithm scs. first might exponential-time brute force algorithm would would complete dataset. instead quick literature search reveals existence greedy heuristic. initially start string made arbitrary read. expand string pick read overlaps current string maximum possible among reads. extend string using read repeat reads accounted for. implementing heuristic dataset. comparing solution inﬂuenza genome diﬀerent. moreover solution shorter inﬂuenza genome. after validating solution indeed common superstring reads start investigate reason missing sequences. sequences appear multiple times virus genome appear solution. follow domain expert biologist case check solution makes sense. careful analysis solution observes something strange. genomes typically full repetitive elements sequences appear multiple locations genome. however solution repeat content. could problem using heuristic instead exact algorithm? thinking problem great insight capture following theorem theorem indicates problem heuristic. instead serious shortcoming formulation itself. speciﬁcally states would faithfully represent repeats known problem over-collapsing repeats. result theorem correct genomes. turns intuition using parsimony completely correct. problem useful problem formulation. need problem formulation avoids collapsing repeats. part issue allow leeway reconstructing genome. allowed create parts genome supported reads. example proof underlined characters gscs indicate location unsupported junction. string occur reads. could consider adding constraint -mer solution must contained read hope would constraint notation refer substring whose ﬁrst position whose last position check constraint strong thinking typical sequencing experiment described problem probability exist consecutive positions genome spanned read computed length genome number length reads assume reads sampled uniformly random genome. probability extremely small hence assumption every -mer genome included read reasonable back example—we make sure constraint works give correct answer. indeed solution gscs would longer valid since underlined -mer part read. solution here character relative gscs underlined. notice even though every -mer solution exists reads gsol still shorter true genome. however consider -mers instead mers part read. verify require every solution -mer present reads gtrue ﬁnally becomes unique solution problem. generally then could increasing value require solution k-mer included reads help reconstruct true genome? reads distributed evenly throughout million nucleotide genome i.e. precisely read sampled every ﬁfth position. since read long every range width spanned read. even general case reads sampled uniformly random still expect ranges much wider spanned. fact given read length genome length number reads derive probability range size true genome spanned read. omit derivation here assume chosen probability neglible. collection strings k-mer-spectrum naturally deﬁned k-mers i.e. spk. last problem formulation could stated requiring output satisﬁes generalize solving computer science problems scratch daunting task. theoretical computer scientists appreciate beauty challenge brand problem best connect something well-studied. problem formulations belong realm stringology clear solve problem using stringology toolbox. cases useful change perspectives diﬀerent toolbox might apply. graph theory oﬀers intuitive visual representation deeply studied area. walk directed graph sequence edges every edge leaves vertex previous edge enters; walk edge-covering visits every edge least once. notice walk spells string whose k-mer spectrum exactly edges walk visits therefore subset spk. likewise string whose k-mer spectrum subset spelled unique walk graph. walk visits discussed section deal np-hardness adding removing constraints make problem tractable. since interested researcher quite talented would come across chinese postman problem search algorithm. chinese postman problem shortest cyclical edge-covering walk problem known solvable polynomial time. seems similar problem include superstring requirement. dropping requirement though retaining weaker requirement solution includes k-mers reads. bruijn graph gives another understand problem helps alleviate problem over-collapsing repeats. solution constrained walk cover graph cannot simply include arbitrary characters jump diﬀerent vertices. reader figure verify gscs gsol spelled walk bruijn graph example. addition over-collapsing repeats problem suﬀered intractable. computational complexity problem interested researcher would attempt answer known absense would attempt prove np-hardness algorithm herself. case indeed minor variation chinese postman problem solve polynomial time. changing toolbox allowed make connection well-studied problem identify formulation solved polynomial time. however make additional simpliﬁcation dropping superstring requirement. result might read represented anywhere solution. intuition guided towards choosing ﬁrst option section think simpliﬁcation worth making. verify intuition mislead formulation useful? process formulating problem make several simplifying assumptions. none hold perfectly real world. thus even best algorithm still fail miserably faced real simulated data violates assumptions. ultimate test algorithm’s usefulness therefore fairs assumptions satisﬁed. referred robustness algorithm. case formulation problem based several assumptions. assumption errors reads. could course modularize problem error-correction algorithm pre-processing step. even perfect errors remain. another assumption every k-mer genome included read. recall chose value probability missing k-mer negligible assumption reads sampled uniformly random genome. however sometimes case certain genomic regions diﬃcult sequence structure. thus regions little sampled reads resulting called coverage gaps. testing algorithm real data ultimately uncover useful. however many cases know ground truth real data. makes measuring accuracy algorithm diﬃcult. even ground truth available test real data makes hard identify algorithm’s point failure. ﬁrst stumbling block problem formulation ﬂawed even data satisﬁes assumptions. second algorithm robust respect violation assumptions. third even robust assumptions known aspects real data understand problematic algorithm. next simulated data models real data extent understand example generate reads errors coverage gaps mimicking observe real data. gives controlled environment verify algorithm passes second stumbling block. buoyed ability problem solve small example figure implement polynomial time algorithm check usefulness. follow advice previous section ﬁrst algorithm simulated inﬂuenza data. profound dismay solution match true genome. examine solution closer contains many long correct segments arranged wrong order. problem turns usually many optimal solutions looking buijn graphs simulations observe interesting pattern. consider example figure graph contains three bubbles optimal solutions depending order choose traverse top/bottom part bubble. example abcdefgbcdefh abcdefgbcdefh optimal solutions. example generalized bubbles creating exponentially many optimal solutions. clearly picking arbitrary unlikely give correct genome. could culprit decision drop superstring requirement? length paths connecting consecutive bubbles larger read length would still exponentially many solutions. culprit before repeats. repeats appearing least twice solution. able point realize fundamental limitation problem matter genome repetitive structure never able recover problem seems unsolvable abandon then frustration? even quit computer science altogether? maybe that thing. attempted genome reconstruction deﬁned string spelled shortest edge-covering walk dbk. though many genome reconstructions based reordering basic sequences. formalize notion saying string safe respect genome reconstruction substring relax requirements solution hope attainable recover safe strings instead genome reconstruction refer string output contig. actually shortest requirement notion genome reconstruction proven nothing trouble ultimately helped drop consider problem respect genome reconstructions strings spelled edge-covering walks dbk. implicitly deﬁned optimization problem feasible solution safe strings optimization criterion number contigs. unlike problem maximizing optimization criterion. note without optimization criterion formulation would useful feasible solution simply output every k-mer separate safe string. k-mers certainly safe usually many safe strings. obtain algorithm problem draw intuition examples. consider figure edge-covering walk graph visit walk enters start choice continue capture property makes safe. unitig path vertices except ﬁrst incoming edge vertices except last outgoing edge. single vertex always considered unitig. maximal unitig unitig cannot extended either direction. shown maximal unitigs graph partition vertex partition unique. based intuition deﬁne unitig algorithm outputs strings spelled maximal unitigs graph. easy implement algorithm polynomial time solve problem recall source vertex incoming edges sink vertex outgoing edges. good news least genome reconstruction source sink prove maximal unitigs always safe. proof. unitig edge-covering walk dbk. note must begin source sink. properties bruijn graph spells string substring string spelled subwalk therefore prove induction subwalk base case unitig single vertex trivially subwalk general induction hypothesis gives subwalk since outgoing edge sink. hence vp−. possible vertex follow out-neighbor. thus subwalk news unitig algorithm optimal solution problem example figure safe contig unitig. figure example safe contig unitig. thus unitig algorithm heuristic problem ﬁnds feasible solution optimal one. nevertheless still strategy section check usefulness unitig algorithm. stressed throughout ultimate test algorithm’s usefulness whether solves formulation optimally whether performs well experimental evaluations. therefore proceed ﬁrst stage evaluation unitig algorithm simulated inﬂuenza data. eureka contigs indeed substrings inﬂuenza genome contigs fairly long could proceed second stage evaluation simulating reads gaps coverage. unitig algorithm would still produce long accurate contigs though occasionally contig substring inﬂuenza genome. contigs would rare would tolerate move introducing erroneous reads simulations. would contigs short inaccurate. choice ﬁrst option section turns mistake. hinted previously could still switch third option formulating solving problem correcting errors reads. that would combination error correction algorithm unitig algorithm would perform well simulations errors coverage gaps. moreover combination would also perform well real data summary unitig algorithm combined error correction performs well experimental evaluations robust errors coverage gaps aspects real data mentioned here. useful algorithm solving original problem simultaneously careful investigation problem reveals fact optimal polynomial time algorithm. algorithm called omnitig algorithm. cover works here since fairly involved. might seem omnitig algorithm optimal strictly better unitig algorithm. however must give absolute credence superiority solution optimal problem formulation. omnitig algorithm recently proposed ﬁrst stage evaluation performed. whether ultimately useful unitig algorithm depend fares subjected second third stages evaluation. reader hopefully grown appreciate process applying computer science techniques biological problem. process happen within context single paper typically spans many years. often biologists years analyze data quick-and-dirty algorithms open discussions though become integrated understanding impossible disentangle assign proper credit speciﬁc individuals. also grateful early feedback manuscript alexandru tomescu jens stoye adam smith well feedback anonymous reviewers. work supported part awards dbi- ccf- iis- iis-.", "year": "2017"}