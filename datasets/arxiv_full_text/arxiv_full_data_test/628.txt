{"title": "Designing RNA Secondary Structures is Hard", "tag": "q-bio", "abstract": " An RNA sequence is a word over an alphabet on four elements $\\{A,C,G,U\\}$ called bases. RNA sequences fold into secondary structures where some bases match one another while others remain unpaired. Pseudoknot-free secondary structures can be represented as well-parenthesized expressions with additional dots, where pairs of matching parentheses symbolize paired bases and dots, unpaired bases. The two fundamental problems in RNA algorithmic are to predict how sequences fold within some model of energy and to design sequences of bases which will fold into targeted secondary structures. Predicting how a given RNA sequence folds into a pseudoknot-free secondary structure is known to be solvable in cubic time since the eighties and in truly subcubic time by a recent result of Bringmann et al. (FOCS 2016). As a stark contrast, it is unknown whether or not designing a given RNA secondary structure is a tractable task; this has been raised as a challenging open question by Anne Condon (ICALP 2003). Because of its crucial importance in a number of fields such as pharmaceutical research and biochemistry, there are dozens of heuristics and software libraries dedicated to RNA secondary structure design. It is therefore rather surprising that the computational complexity of this central problem in bioinformatics has been unsettled for decades.  In this paper we show that, in the simplest model of energy which is the Watson-Crick model the design of secondary structures is NP-complete if one adds natural constraints of the form: index $i$ of the sequence has to be labeled by base $b$. This negative result suggests that the same lower bound holds for more realistic models of energy. It is noteworthy that the additional constraints are by no means artificial: they are provided by all the RNA design pieces of software and they do correspond to the actual practice. ", "text": "middlesex university department computer science london edouard.bonnetdauphine.fr faculty mathematics information science warsaw university technology warsaw poland abstract. sequence word alphabet four elements called bases. sequences fold secondary structures bases pair another others remain unpaired. pseudoknot-free secondary structures represented well-parenthesized expressions additional dots pairs matching parentheses symbolize paired bases dots unpaired bases. fundamental problems algorithmic predict sequences fold within model energy design sequences bases fold targeted secondary structures. predicting given sequence folds pseudoknot-free secondary structure known solvable cubic time since eighties truly subcubic time recent result bringmann whereas lyngsø shown np-complete pseudoknots allowed stark contrast unknown whether designing given secondary structure tractable task; raised challenging open question anne condon crucial importance number ﬁelds pharmaceutical research biochemistry dozens heuristics software libraries dedicated secondary structure design. therefore rather surprising computational complexity central problem bioinformatics unsettled decades. paper show that simplest model energy watson-crick model design secondary structures np-complete adds natural constraints form index sequence labeled base negative result suggests lower bound holds realistic models energy. noteworthy additional constraints means artiﬁcial provided design pieces software correspond actual practice reduction variant -sat main ingredients arches parentheses diﬀerent widths linear order interleaving variables clauses intended rematching strategy increases number pairs three literals clause false. correctness construction also quite intricate; relies polynomial algorithm design saturated structures secondary structures without dots haleš counting arguments concise case analysis. ribonucleic acid molecule playing important role besides deoxyribonucleic acid proteins. chain nucleotides represented sequence -letter alphabet denoting ﬁrst letter corresponding base. unlike single stranded folds itself bases linked form stable compact structure. pairing forms secondary structure molecule; primary structure sequence nucleotides tertiary structure shape. predicting molecule folds vital understand biological function. experiments reveal secondary structure strand tends follow laws thermodynamics. given model associating free-energy value secondary structures widely accepted since pioneer work chemistry nobel laureate christian anﬁnsen secondary structure sequence predicted minimum freeenergy i.e. ensuring greatest stability. simple energy model watson-crick model allowing pair pair model simply realized structure greatest number pairs. folding. stem-loop hairpin loop building block secondary structures. consists series consecutive base pairs ending loop unpaired nucleotides. pseudoknot occurs nucleotides loop pair somewhere else strand. pseudoknot-free secondary structures correspond well nested structures. represented well-parenthesized expression matching parentheses symbolize base pairs additional dots symbolize unpaired nucleotides. given sequence nucleotides folding problem consists ﬁnding pseudoknotfree secondary structure minimum free-energy. folding solved simple dynamic programming time size sequence since result early work devoted propose methods secondary structure prediction. recently ﬁrst truly subcubic algorithm folding proposed bringmann runs deterministic time randomized time faster polynomial-time approximation algorithms later obtained pseudoknots allowed computational complexity predicting folds gets blurry. short answer would folding prediction becomes npcomplete observing none three hardness constructions ideal ﬁrst value free-energy ﬁxed speciﬁed part input assume planar pseudoknots legal lyngsø gives additional np-hardness proofs work seemingly close models; distant watson-crick. however np-hardness model crucially needs alphabet size unbounded np-hardness model carries binary alphabet. restricted types pseudoknots allowed dynamic programming still works yields polynomial-time algorithms worse running times pseudoknot-free case hypothesis pseudoknots form pseudoknot-free pairs o-time complexity attained simpler model approach based maximum weighted matchings makes folding prediction tractable general pseudoknots design. inverse folding problem called design given secondary structure sequence bases uniquely folds structure; report sequence exist. sequence must fold structure instead structure. particular watson-crick model structure sequence fold must strictly fewer pairs. sequence exists call design secondary structure. problem introduced early paper which date citations motivation study problem comes fact functions performed particular sequences strongly inﬂuenced secondary structures sequences fold into. thus important step towards designing sequences perform given functions able design sequences fold given secondary structures surprisingly complexity design still unknown despite decades works explicitly stated major open problem exceptional central problem computational biology schnall-levin gave np-hardness proof general problem however applicable design energy model would depend -sat instance reduction clearly realistic solving design ﬁnds applications multiple ﬁelds pharmaceutical research biochemistry well synthetic biology nanostructures latter areas creating enhanced desirable properties. also major step towards functional molecular design. therefore many algorithms software products solving inverse folding problem churkin compare main freewares solving design rnainverse antarna rnaifold either heuristics meta-heuristics exponential running time. also mention eterna project online game players correct sequence given structure recently haleš gave suﬃcient conditions answer problem polynomial time main result show structure saturated i.e. contain unpaired letter design exists– found linear time greedy procedure. case saturated structures existence design solely based maximum degree tree representing structure. authors also show smaller alphabets general secondary structures design tractable. line research later continued jedwab authors presented inﬁnite family designable structures containing unpaired letters. again characterization structures given terms trees. following name precoloring extension problem graphs extension version inverse folding problem design additional constraint indices sequence contain speciﬁed base. lyngsø observes assumption biologically coherent most recent methods allow position speciﬁc constraints addition folding target structure designed sequence also required certain positions particular nucleotide indeed addition target structure force bases positions ensure molecule possesses given function. zhou also propose method solve design positions within sequence constrained certain bases rodrigo impose presence certain sequence speciﬁc position structure borujeni enforce presence given subsequence paired start codon start translation proteins furthermore software libraries solving design allow additional unary constraints instances eterna project contain immutable nucleotides. thus appears design secondary structures better captured design extension restriction design. ideas reduction. main reason complexity designing secondary structures open twenty years diﬃcult create challenging structures intended sequence fold undesired better structure; alone actually prove considerably easier exhibit alternative better structure sequence. indeed former case needs argue structures compatible sequence latter needs particular structure. mind yes-instances starting np-hard problem much problematic deal no-instances. reduction e-sat clause gadget contains unpaired bases surrounded arch nested parentheses. number unpaired bases width arch three literals clause unsatisﬁed obtain better structure deleting arch matching previously unpaired bases previously unpaired bases corresponding variable gadgets. however literals clause unsatisﬁed rematching strategy ends worst structure. combat improving rematching strategy sequences want interpret satisfying assignments arches increasing widths represent variables. allows simple counting argument signiﬁcantly prune undesired rematchings. another technical ingredient display variable clause gadgets interleaved carefully chosen order. interestingly also make fact saturated structures eﬃciently designed correctness reduction. robustness reduction. established watson-crick energy model hardness result enjoys following healthy properties. need -letter alphabet sequences naturally corresponds four nucleotides optimal light paper haleš authors show tractability designing secondary structures alphabet size free-energy computed ﬁxed hence part input cannot used artiﬁcially encode hard task. need pseudoknots –which make folding prediction intractable– obtain hardness. watson-crick simplest model result strongly suggests secondary structure design hard authoritative models. also note structures produced reduction reasonably realistic. contain building blocks nested parentheses surrounding dots. interestingly structure mentioned known stem-loop building block structures. finally believe ideas developed reduction adapted energy models prove useful show np-hardness even element sequence constrained speciﬁed nucleotide. organization. rest paper organized follows. section formally introduce required notions deﬁne problem design section show main contribution even simple watson-crick model designing secondary structures np-hard input structure comes imposed bases speciﬁc positions. short design extension np-hard. section give simple algorithms complexity better brute-force design positive integer denote positive integers greater given word length alphabet denotes i-th letter sequences extensions. sequence word bases sequence word represents represents represents represents letters paired call base element partial sequence word extension partial sequence sequence length secondary structures. pseudoknot-free secondary structure word alphabet removes remaining word well parenthesized expression. follows always omit adjective pseudoknot-free. wellparenthesized expression word number preﬁx word refer unpaired letter unmatched letter simply opposed paired. structure saturated contain unpaired letter. designs. well-parenthesized expression opening parenthesis index said matched closing parenthesis index smallest index satisfy multiset contains number opening closing parentheses. extend deﬁnition structures ignoring unpaired letters. structure compatible sequence length indices paired }}). sequence design structure compatible every structure compatible strictly unpaired letters. partial sequence extended design extension design also sequence labels index structure size base design extension given structure partial sequence length. goal decide extended design design problem seen special case partial sequence contains symbols. words index structure constrained labeled speciﬁc base introduction argued design extension perhaps natural restriction design. example partial sequence. extension structure well-parenthesized expression). compatible however design since also compatible number unpaired letters actually cannot extended design since none design observe that order compatible ﬁrst bases paired third paired following sequence design tree representation structure. structure seen rooted tree whose nodes either pairs matching parentheses unmatched letters parent-child relation deﬁned nestedness parentheses/unmatched letters. following haleš convenience also special node virtual root role simplify working structures surrounded parentheses. note children node ordered unpaired node always leaf. every substructure deﬁned subtree called subtree. observe every subword subtree. degree node number neighbors excluding unpaired ones finally degree structure mean maximum degree node tree. proof. assume subtree labeled design. second structure compatible least many paired letters structure obtained replacing subtree another structure compatible least many paired letters contradiction. proof. design extension polynomial dynamic programming algorithm solve folding papers slightly adapted test uniqueness maximally matched structure. therefore guess extension partial sequence design check tuned dynamic programming. reduce np-hard problem e-sat variant -sat clauses exactly three distinct literals. problem remains np-hard variable appears four times instance variables thus -clauses. build equivalent instance design extension structure partial sequence length structure every variable every literal introduce gadget containing consecutive unpaired letters. unpaired letter hence represents overall number unpaired letters. might useful keep mind inequalities proof hold assume greater large constant potential solution extension whose restriction subtree corresponding variable gadget design. lemma know solution design extension instance potential solution. lemma potential solution dots hxii receive label receive label proof. indeed labeled would distinct structure number pairs matches ﬁrst closing parenthesis consider case labeled another labeled dots matched together yielding structure strictly pairs. clause gadget. clause gadgets structure entirely labeled consider -clause {xi¬xi} deﬁne literal gadget literal gadget denoted lhℓai hxai opening parentheses labeled closing parentheses dots labeled literal positive negative literal gadget denoted l−jyhℓii obtained lhℓii removal pairs parentheses surrounding arch; number l−jyhℓbi l−jyhℓci. outermost opening parentheses shcji labeled forcing corresponding closing parentheses labeled next opening parentheses labeled matching parentheses labeled extra opening parentheses fig. variable literal gadgets hxii labeled –setting true hxii entirely rematched lh¬xii note lhxii lh¬xii depends truth assignment appear positively negatively clause. surrounding lhℓai labeled matching parentheses label remaining parentheses speciﬁed figure refer outermost pairs parentheses arch also call ﬁrst pairs ﬁrst layer arch next pairs second layer. denote indices second layer clause gadget shcji. indices opening parentheses indices closing parentheses finally overall construction. join gadgets binary tree pairs parentheses height labeled illustrated figure requirement labeling fully matching binary tree onto itself. words labeling design structure restricted parentheses binary tree. pair matched parentheses labeled opening parenthesis labeled possibility labeling binary tree outermost pair parentheses recursively children parentheses labeled children parentheses labeled denote indices letters binary tree. leaves binary tree place variable clause gadgets. gadgets hxni placed left right. reserve room hxii hxi+i clause gadgets according following rule. clause variables insert gadget shcji somewhere hxbi hxci; words right hxbi left hxci. obviously ordering variable clause gadgets found polynomial time. order clause gadgets consecutive variable gadgets hxii hxi+i important chosen arbitrarily. need power might figure empty leaves without variable gadget clause gadget. show partial sequence extended design structure satisﬁable. whole construction seen simulating following game equivalent -sat opponent interesting role. boxes literals written box. beginning game opponent want rich chooses truth assignment variables appearing boxes. opening costs favorite currency rules open box. open inside object literal. turn object literal unsatisﬁed object worthless otherwise. knowing that decide open three literals unsatisﬁed open least satisﬁed literal lose least formula satisﬁable opponent computationally almighty choose satisfying assignment. anything decide open since negative outcome. case opening paying corresponds destroying clause gadget pairs innermost parentheses surrounding three literal gadgets pairs parentheses additional constant number within clause gadget); turning object found inside associated unsatisﬁed literal corresponds fully pairing variable gadget matching literal gadget. unsatisﬁable implies design extension. assume instance satisﬁable. lemma already observed every potential solution corresponds truth assignment potential solution corresponding variable assignment. assumption clause satisﬁed suppose clause structures compatible sequence parenthesis index rematched parenthesis index indices matching parentheses similarly letter index rematched letter index nature structures obvious context precise them. exhibit structure compatible paired letters paragraph next role played role opening parentheses ﬁrst layer arch rematched last closing parentheses arch closing parentheses ﬁrst layer arch rematched ﬁrst opening parentheses arch letters whose indices become unpaired. fully rematch hxbi hxai hxci l−jyhℓbi lhℓai l−jyhℓci respectively. possible since three literals unsatisﬁed means that dots hxii labeled dots lhℓii l−jyhℓii labeled dots matched other. observe extra arch lhℓai absorbs ﬁrst opening parentheses arch last closing parentheses arch whereas ﬁrst layer arch shcji absorbs last closing parentheses arch ﬁrst opening parentheses arch rematching sets consecutive dots incurs pairs. count number pairs lose. break ⌈log⌉ pairs gadgets hxai hxbi hxci lhℓai l−jyhℓbi l−jyhℓci shcji rematched other. pairs break parentheses paths going gadgets root binary tree. actually removing parentheses would still work. also broke pairs indices plus pairs parentheses shcji part arch. rest matched structure least ⌈log⌉ −⌉+) pairs. hence partially labeled cannot extended design. satisﬁable implies design extension. satisﬁable assignment extension corresponding show design sake contradiction assume structure compatible least many pairs take maximally matched structure compatible strictly pairs proof. assume match unpaired letters least number paired letters implies matches exactly letters structure obtained restricting paired letters restricted paired letters. construction distinct saturated structures compatible proof theorem authors show every saturated structure degree design design found greedy labeling. greedy labeling labeling assign labels child paired parentheses labeled avoids labeling siblings pair i-j. observe degree following lemma straightforward proves useful argue quality structure reachable partially built structure. based simple counting argument. denote number occurrences word around match) labeling complete then integer implies letters remain unpaired. proof. indices letters labeled surrounding parentheses base index matched base index also number exceeds number bases pairing fig. pairing letter hxii paired letter hxi′i cannot give suﬃciently paired structure. single blue edge represents arch thickness y-axis corresponds lower bound imbalance subsequence surrounded pair depicted dashed edge. gray areas mark positions actually present. regions greater pairing necessarily yields worse structure proof. illustrated figure fact general extends variable gadgets variable plus literal gadgets. suppose base labeling matched base labeling then pair would surround subsequence i′|y provided bases appear within clause gadget. remember that gadget clause extreme literals deprived matching parentheses arch middle literal additional pairs parentheses arch labeled instead explains appear upper bound imbalance. inequality holds three subcases variable-variable variable-clause clause-clause pair would surround subsequence finally base labeling matched base labeling imbalance word surrounded pair larger recall unpaired letters. lemma cases would least unpaired letters; contradiction. apply lemma argue second layer clause arches cannot signiﬁcantly rematched. augmented constant number clause gadget indices corresponding parentheses arch. proof. first match would indeed surround subsequence ′|y. lemma would imply strictly fewer pairs second matching letter index outside would mean match labeling case conclude similarly proof lemma labeled matched labeled lemma lemma index exists. since contains several literal gadgets variable gadget hxii least endpoint pair clause gadget. index clause. none pairs parentheses present otherwise matching would cross. lemma implies pairs unpaired negligible corresponding letters could rematched three literals satisﬁed index satisﬁed literal number pairs parentheses destroyed least best pairs formed linking literal gadgets shcji corresponding variable gadgets. still incurs deﬁcit pairs. dots literal gadget shcji rematched since otherwise maximal reversing locally would provide structure strictly pairs would create crossing. words structure obtained replacing parentheses least endpoint shcji parentheses gadget variable gadgets corresponding unsatisﬁed literals would pairs lemma dots literal gadget shcji rematched another clause gadget shcj′i containing opposite literal argument shcji rematching costs least parentheses total). pairs obtained; case four literals clauses variable unsatisﬁed rematched corresponding variable gadgets. deﬁcit rematching thus reversing locally would provide structure pairs contradicting maximality. consider structure tree representation deﬁne families subtrees found denote node degree denote node least unpaired child degree greater following result haleš proof. input structure length unlabeled elements. tree representation virtual root section know children either matching pair parentheses unpaired letter. ﬁrst step branch possible labelings unlabeled children unlabeled nodes check polynomial time obtained labeling design extends predeﬁned partial labeling. want branch possible labelings children however cases prune search tree know current partial solution extendable design. section know possibilities children look like. either paired children unpaired children paired child without loss generality assume labeled however show case cannot happen often. node least paired children good. tree constructed removing unpaired nodes contracting induced paths single edges moreover virtual root degree remove assume rooted child easy observe following properties number leaves clearly number vertices since every inner node children observe number inner nodes least gives lower bound number good nodes thus every nodes exists good node formally speaking partition constant number nodes family two-elements sets deﬁne injective mapping good nodes consider labeling children nodes children good node time obtain recursion worst case-complexity case achieved gives since constant number nodes paired good nodes blow-up complexity also constant ignored o-notation. correctness described procedure clear follows fact discard labeling cannot appear design. running time procedure determined complexity worst-case branching appears case thus running time bounded unlabeled. cases consider ﬁrst algorithm size problem complexity input structure unlabeled elements. case recall labeling paired child must labeling thus without loss generality assume paired child labeled. also least unpaired children labeled extend labeling unlabeled children. suppose unpaired children obtain recursion finally remark haleš give complete characterization saturated structures design. characterization implies polynomial-time algorithm design problem structures. using bottomdynamic programming tree representation input structure adapt procedure general design extension problem.", "year": "2017"}