{"title": "Nanopore Sequencing Technology and Tools for Genome Assembly:  Computational Analysis of the Current State, Bottlenecks and Future  Directions", "tag": "q-bio", "abstract": " Nanopore sequencing technology has the potential to render other sequencing technologies obsolete with its ability to generate long reads and provide portability. However, high error rates of the technology pose a challenge while generating accurate genome assemblies. The tools used for nanopore sequence analysis are of critical importance as they should overcome the high error rates of the technology. Our goal in this work is to comprehensively analyze current publicly available tools for nanopore sequence analysis to understand their advantages, disadvantages, and performance bottlenecks. It is important to understand where the current tools do not perform well to develop better tools. To this end, we 1) analyze the multiple steps and the associated tools in the genome assembly pipeline using nanopore sequence data, and 2) provide guidelines for determining the appropriate tools for each step. We analyze various combinations of different tools and expose the tradeoffs between accuracy, performance, memory usage and scalability. We conclude that our observations can guide researchers and practitioners in making conscious and effective choices for each step of the genome assembly pipeline using nanopore sequence data. Also, with the help of bottlenecks we have found, developers can improve the current tools or build new ones that are both accurate and fast, in order to overcome the high error rates of the nanopore sequencing technology. ", "text": "department electrical computer engineering carnegie mellon university pittsburgh department computer engineering bilkent university bilkent ankaraturkey department computer science systems group zürich zürich switzerland nanopore sequencing technology potential render sequencing technologies obsolete ability generate long reads provide portability. however high error rates technology pose challenge generating accurate genome assemblies. tools used nanopore sequence analysis critical importance overcome high error rates technology. goal work comprehensively analyze current publicly available tools nanopore sequence analysis understand advantages disadvantages performance bottlenecks. important understand current tools perform well develop better tools. analyze multiple steps associated tools genome assembly pipeline using nanopore sequence data provide guidelines determining appropriate tools step. based analyses make four observations choice tool basecalling plays critical role overcoming high error rates nanopore sequencing technology. read-to-read overlap ﬁnding tools graphmap minimap perform similarly terms accuracy. however minimap lower memory usage faster graphmap. trade-off accuracy performance deciding appropriate tool assembly step. fast less accurate assembler miniasm used quick initial assembly polishing applied increase accuracy leads faster overall assembly. state-of-the-art polishing tool racon generates high-quality consensus sequences providing signiﬁcant speedup another polishing tool nanopolish. analyze various combinations different tools expose tradeoffs accuracy performance memory usage scalability. conclude observations guide researchers practitioners making conscious effective choices step genome assembly pipeline using nanopore sequence data. also help bottlenecks found developers improve current tools build ones accurate fast order overcome high error rates nanopore sequencing technology. next-generation sequencing technologies revolutionized dominated genome sequencing market since ability generate massive amounts data faster speed lower cost existence successful computational tools process analyze large amounts data quickly accurately critically important take advantage technologies science medicine technology. since whole genome organisms cannot sequenced once genome broken smaller fragments. fragment sequenced small pieces sequences generated. reads analyzed following different approaches read mapping novo assembly. read mapping process aligning reads reference genome detect variations sequenced genome. novo assembly method combining reads construct original sequence reference genome exist repetitive regions genome short-read length dominant technologies causes errors ambiguities read mapping poses computational challenges accuracy problems novo assembly repetitive sequences usually longer length short read entire repetitive sequence cannot spanned single short read. thus short reads lead highly-fragmented incomplete assemblies however long read span entire repetitive sequence enable continuous complete assemblies. demand sequencing technologies produce longer reads resulted emergence even newer alternative sequencing technologies. nanopore sequencing technology example technologies produce long read lengths. nanopore sequencing emerging promising single-molecule sequencing technology exhibits many attractive qualities time could potentially surpass current sequencing technologies. nanopore sequencing promises high sequencing throughput cost longer read length require ampliﬁcation step sequencing process using biological nanopores sequencing ﬁrst proposed ﬁrst nanopore sequencing device minion recently made commercially available oxford nanopore technologies minion inexpensive pocket-sized portable high-throughput sequencing apparatus produces data real-time. properties enable potential applications genome sequencing rapid surveillance ebola zika epidemics near-patient testing applications require realtime data analysis. addition minion technology major advantages. first capable generating ultra-long reads minion’s long reads greatly simplify genome assembly process decreasing computational requirements second small portable. minion named ﬁrst sequencing device used outer space help detection life elsewhere universe help size portability help continuous updates minion device nanopore chemistry ﬁrst nanopore human reference genome generated using minion devices despite advantageous characteristics nanopore sequencing major drawback high error rates. released version minion nanopore chemistry called provide higher accuracy higher speed replaced previous version although chemistry improves data accuracy improvements enough cutting-edge applications. thus nanopore sequence analysis tools critical role overcome high error rates take better advantage technology. also faster tools critically needed take better advantage real-time data production capability minion enable real-time data analysis. goal work comprehensively analyze current publiclyavailable tools nanopore sequence analysis understand advantages disadvantages bottlenecks. important understand current tools perform well develop better tools. analyze tools associated multiple steps genome assembly pipeline using nanopore sequence data terms accuracy speed memory efﬁciency scalability. note manuscript presents checkpoint state-of-the-art tools time manuscript submitted. fast moving ﬁeld hope analysis useful expect fundamental conclusions recommendations make independent exact versions tools. output minion signal data represents changes electric current strand passes nanopore. thus pipeline starts signal data. ﬁrst step basecalling translates signal output minion bases generate reads. second step computes pairwise read alignments sufﬁx-preﬁx matches pair reads called read-to-read overlaps. overlap-layout-consensus algorithms used assembly nanopore sequencing reads since olc-algorithms perform better longer error-prone reads olc-based assembly algorithms generate overlap graph node denotes read edge represents sufﬁx-preﬁx match corresponding nodes. third pipeline step genome assembly traverses overlap graph producing layout reads constructing draft assembly. increase accuracy assembly polishing i.e. post-assembly error correction required. fourth step pipeline mapping original basecalled reads generated draft assembly previous step ﬁfth ﬁnal step pipeline polishing assembly help mappings previous step. strand passes nanopore causes drops electric current passing walls pore. amount change current depends type base passing pore. basecalling initial step entire pipeline translates signal output nanopore sequencer bases generate reads. current basecallers divide current signal discrete blocks called events. event-detection event decoded most-likely bases. ideal case consecutive event differ base. however practice case non-stable speed translocation. also determining correct length homopolymers challenging. problems make deletions dominant error nanopore sequencing thus basecalling important step pipeline plays critical role decreasing error rate. analyze state-of-the-art basecalling tools paper detailed comparison basecallers freely available chiron refer reader ongoing basecaller comparison study note ongoing study capture accuracy performance entire genome assembly pipeline using nanopore sequence data. nanonet also developed available github since metrichor requires internet connection source code available nanonet ofﬂine open-source alternative metrichor. nanonet implemented python. also uses basecalling tool supports multi-threading sharing computation needed call single read concurrent threads. words read called time. scrappie newest proprietary basecaller developed ont. named ﬁrst basecaller explicitly addresses basecalling errors homopolymer regions. order determine correct length homopolymers scrappie performs transducer-based basecalling versions scrappie perform basecalling current signal without requiring event detection. c-based local basecaller still development nanocall uses hidden markov models basecalling independently developed research group. released update metrichor also using hmm-based approach basecalling provide ﬁrst ofﬂine open-source alternative metrichor. however update metrichor started perform basecalling powerful rnn-based approach nanocall’s accuracy fell short metrichor’s accuracy thus although nanocall supports upper versions nanopore data usefulness limited nanocall c++-based command-line tool. supports multi-threading thread performs basecalling different groups reads. deepnano also independently developed research group update. uses rnn-based approach perform basecalling. thus considered ﬁrst rnn-based basecaller. deepnano implemented python. multi-threading support. previous genome assembly methods designed accurate short reads approach suitable nanopore reads high error rates current nanopore sequencing devices instead overlap-layout-consensus algorithms used nanopore sequencing reads since perform better longer error-prone reads. olc-based assembly algorithms start ﬁnding read-to-read overlaps second step pipeline. read-to-read overlap deﬁned common sequence reads graphmap minimap commonly-used state-of-the-art tools step k-length substrings creates hash table. graphmap uses gapped k-mers i.e. k-mers contain insertions deletions hash table k-mer entry three pieces information stored k-mer string index read position read corresponding k-mer comes from. graphmap detects overlaps ﬁnding k-mer similarity given reads. design graphmap highly sensitive accurate tool errorprone long reads. command-line tool written c++. graphmap used read-to-read overlap ﬁnding graphmap owler command read mapping graphmap align command. minimap also partitions entire read dataset k-mers instead creating hash table full k-mers ﬁnds minimum representative k-mers called minimizers creates hash table minimizers. minimap ﬁnds overlaps reads ﬁnding minimizer similarity. goals using minimizers reduce storage requirement tool storing fewer k-mers accelerate overlap ﬁnding process reducing search span. minimap also sorts k-mers cache efﬁciency. minimap fast cacheefﬁcient lose sensitivity storing minimizers since chosen minimizers represent whole k-mers. minimap command-line tool written like graphmap overlaps read sets reads full genome. ﬁnding read-to-read overlaps olc-based assembly algorithms generate overlap graph. genome assembly performed traversing graph producing layout reads constructing draft assembly. canu miniasm commonly-used error-prone long-read assemblers canu performs error-correction initial step pipeline. ﬁnds overlaps uncorrected reads uses errorcorrection. purpose error-correction improve accuracy bases reads error-correction step canu ﬁnds overlaps corrected reads constructs draft assembly additional trimming step. however error-correction computationally expensive step. pipeline canu implements read-to-read overlap ﬁnding tool users need perform step explicitly running canu. steps canu pipeline multi-threaded. canu detects resources available computer starting pipeline automatically assigns number threads number processes amount memory based available resources assembled genome’s estimated size. miniasm skips error-correction step since computationally expensive. constructs draft assembly uncorrected read overlaps computed previous step. although miniasm lowers computational cost thus accelerates simpliﬁes assembly accuracy draft assembly depends directly accuracy tool metrichor recurrent neural network recurrent neural network nanonet recurrent neural network scrappie nanocall hidden markov model deepnano recurrent neural network source https//metrichor.com/ https//github.com/nanoporetech/nanonet https//github.com/nanoporetech/scrappie https//github.com/mateidavid/nanocall https//bitbucket.org/vboza/deepnano order increase accuracy assembly especially rapid assembly methods like miniasm errorcorrection step polishing required. polishing i.e. postassembly error-correction improves accuracy draft assembly mapping reads assembly changing assembly increase local similarity reads ﬁrst step polishing mapping basecalled reads generated draft assembly previous step. commonly-used long read mappers nanopore data bwa-mem read-to-read overlap ﬁnding tools graphmap minimap also used step since also read mapping mode nanopolish uses signal data reads along mappings previous step improve assembly base quality evaluating maximizing probabilities base hidden markov model-based approach increase accuracy draft assembly correcting homopolymer-rich parts genome. although approach increase accuracy signiﬁcantly computationally expensive thus time consuming. nanopolish developers recommend bwa-mem read mapper running nanopolish racon constructs partial order alignment graphs order consensus sequence reads draft assembly. dividing sequence segments racon tries best alignment increase accuracy draft assembly. racon fast polishing tool promise high increase accuracy nanopolish promises. however multiple iterations racon runs combination racon nanopolish runs improve accuracy signiﬁcantly. racon minion sequencing types workﬂows. workﬂow template strand double-stranded sequenced. contrast workﬂow help hairpin ligation template complement strands pass pore sequenced. release chemistry data became usable contrast previous chemistries. thus perform analysis tools data. minion outputs fast format read. fast format hierarchical data format capable storing signal data basecalled data returned metrichor. dataset includes reads i.e. fast ﬁles. since ﬁles include signal data basecalled reads dataset using local basecallers convert signal data basecalled reads using already basecalled reads metrichor. work accuracy performance evaluations different tools three separate systems different speciﬁcations. ﬁrst computer ﬁrst part analysis accuracy analysis. second third computers second part analysis performance analysis compare scalability analyzed tools machines different speciﬁcations choose ﬁrst system evaluation since larger memory capacity usual server help large number cores tasks parallelized easily order output data quickly. choose second system called desktop since represents commonly-used desktop server. choose third system called bigmem large memory capacity. big-mem system useful would like results quickly. numa computer memory design processor accesses local memory faster non-local memory numa node composed local memory cores hyper-threading intel’s simultaneous multithreading implementation compare draft assembly generated assembly step improved assembly generated polishing step reference genome using dnadiff command mummer package metrics measure accuracy deﬁned table number bases assembly number contigs average identity coverage number mismatches number indels. analyze performance tool running associated command-line tool /usr/bin/time command. four metrics quantify performance deﬁned table wall clock time time peak memory usage parallel speedup. section present results obtained analyzing performance different tools step genome assembly pipeline using nanopore sequence data terms accuracy performance using metrics provide table table additionally table shows tool version executed command output analyzed tool. divide analysis three main parts. ﬁrst part analysis examine ﬁrst three steps pipeline ﬁrst execute basecalling tool since metrichor cloud-based tool source code available cannot execute metrichor performance metrics recording performance metrics basecaller execute either graphmap minimap followed miniasm canu itself record performance metrics run. obtain draft assembly combination basecalling read-to-read overlap ﬁnding assembly tools. draft assembly assess accuracy comparing resulting draft assembly existing reference genome. show accuracy results table show performance results table refer tables sections second part analysis examine last steps pipeline obtained draft assembly execute possible combination different read mappers different polishers record performance metrics step obtain polished assembly assess accuracy comparing existing reference genome. analyses ﬁrst system logical cores execute tool using threads possible maximum number deﬁnition total number bases assembly total number segments assembly percentage similarity assembly reference genome ratio number aligned bases reference genome length reference genome total number single-base differences assembly reference genome total number insertions deletions assembly reference genome deﬁnition elapsed time start program total amount time spends user mode kernel mode maximum amount memory used program whole lifetime ratio time program thread time threads third part analysis assess scalability tools multi-threading support. purpose second third systems compare scalability tools different system conﬁgurations. tool change number threads observe corresponding change speed memory usage parallel speedup. results depicted figures refer throughout sections discuss section ont’s basecallers metrichor nanonet scrappie another basecaller developed boza deepnano recurrent neural networks basecalling whereas nanocall developed david uses hidden markov models basecalling. using rnns powerful basecalling approach using hmms since make assumptions sequence length affected repeats sequence however still challenging determine correct length homopolymers even rnn. local version metrichor nanonet metrichor’s similar accuracy trends expected. addition power rnn-based approach scrappie tries solve homopolymer basecalling problem. although scrappie early stage development leads smaller number indels metrichor nanonet. nanocall’s poor accuracy results simple hmmbased approach uses. although deepnano performs better nanocall help rnn-based approach results higher number indels lower coverage reference genome. computationally-intensive algorithms. hmmbased basecalling viterbi algorithm used decoding. viterbi algorithm sequential technique computation cannot currently parallelized multithreading. however rnn-based basecalling multiple threads work different sections neural network thus computation parallelized multithreading. order measure compare performance selected basecallers ﬁrst compare recorded wall clock time time memory usage metrics scenario ﬁrst step pipeline. metrichor metrichor minimap miniasm metrichor graphmap miniasm nanonet nanonet nanonet scrappie scrappie scrappie nanocall nanocall minimap miniasm nanocall graphmap miniasm deepnano deepnano minimap miniasm deepnano graphmap miniasm metrichor metrichor minimap miniasm metrichor graphmap miniasm nanonet nanonet nanonet scrappie scrappie scrappie nanocall nanocall minimap miniasm nanocall graphmap miniasm deepnano deepnano minimap miniasm deepnano graphmap miniasm deeper understanding tools’ advantages disadvantages bottlenecks also perform scalability analysis basecaller running desktop server big-mem server separately threads measuring performance metrics conﬁguration. metrichor deepnano included analysis metrichor cloud-based tool source code available change number threads deepnano support multi-threading. figure shows speed memory usage parallel speedup results evaluations. make four observations. mainly desktop’s higher frequency indication three tools computationally expensive. larger memory capacity larger last-level cache capacity big-mem cannot make higher speed desktop thread. scrappie nanocall thread performs basecalling different groups reads. thus thread allocates memory space corresponding data. causes linear increase memory usage level parallelism increases. nanonet threads wall clock time peak memory usage parallel speedup results obtained desktop big-mem systems. left column shows results desktop system right column shows results big-mem system. simultaneous multithreading speciﬁcally intel’s hyperthreading helps decrease total runtime provide linear speedup number threads cpu-intensive workload scrappie nanocall nanonet. threads executed cpu-bound wait memory requests hyperthreading provide linear speedup contention causes shared resources computation. phenomenon analyzed extensively application domains nanonet data shared threads thread performs different computations data. numa nodes big-mem data shared multiple numa nodes negatively affects speedup nanonet accessing data located another node requires longer latency accessing data located local memory. multiple numa nodes start taking role computation nanocall performs better terms scalability since require data sharing different threads. summary. based observations make analyzed basecalling tools conclude choice tool step plays important role overcome high error rates nanopore sequencing technology. basecalling recurrent neural networks provides higher accuracy higher speed basecalling hidden markov models newest basecaller scrappie also potential overcome homopolymer basecalling problem. discuss section graphmap minimap commonly-used tools step. graphmap ﬁnds overlaps using kmer similarity whereas minimap ﬁnds using minimizers instead full k-mers. accuracy done graphmap ﬁnding overlaps help full k-mers highly-sensitive accurate approach. however also resource-intensive. reason instead full k-mers minimap uses minimum representative k-mers minimizers alternative approach ﬁnding overlaps. order compare accuracy approaches categorize results table based read-to-read overlap ﬁnding tools. words look rows basecaller assembler different read-to-read overlap ﬁnder that compare according deﬁned accuracy metrics. make following major observation. mainly minimap stores minimizers instead k-mers. storing full k-mers graphmap requires larger hash table thus higher memory usage minimap. high amount memory requirement causes graphmap desktop system none selected number thread units. since graphmap stores k-mers graphmap needs scan large dataset ﬁnding overlaps reads. however minimap size dataset needs scanned greatly shrunk storing minimizers describe observation thus minimap performs much less computation leading speedup. another indication different memory usage effect speed computation last-level cache miss rates tools. miss rate minimap whereas miss rate graphmap since size data needed graphmap much larger size graphmap experiences misses frequently. result graphmap stalls longer waiting data accesses main memory negatively affects speed tool. lower computational workload lower memory usage minimap scalable graphmap. however minimap threads ﬁnish work wait active threads ﬁnish workloads starting work order prevent higher memory usage. this number threads reaches high number synchronization overhead greatly increases causing parallel speedup reduce. graphmap suffer synchronization bottleneck hence experience decrease speedup. however graphmap’s speedup saturates number threads reaches high number data sharing threads. summary. according observations make graphmap minimap conclude storing minimizers instead k-mers done minimap affect overall accuracy ﬁrst three steps pipeline. moreover storing minimizers minimap much lower memory usage thus much higher performance graphmap. minimap graphmap signiﬁcantly different effect accuracy generated draft assemblies. minimap lose sensitivity storing minimizers instead full k-mers. order compare performance graphmap minimap categorize results table based read-to-read overlap ﬁnding tools similar describe results table accuracy analysis. also perform scalability analysis tools running big-mem server threads measuring performance metrics. high memory usage graphmap data necessary tool memory desktop server graphmap exits memory allocation exception. thus could perform scalability analysis graphmap desktop server. figure depicts speed memory usage parallel speedup results scalability analysis graphmap minimap. make following three observations according results table figure order compare performance canu miniasm categorize results table based assembly tools similar table accuracy analysis. could perform scalability analysis tools since canu auto-conﬁguration mechanism sub-step pipeline allow change number threads miniasm support multithreading. make following observation according results table summary. according observations make canu miniasm tradeoff accuracy performance deciding appropriate tool step. canu produces highly accurate assemblies resource intensive slow. contrast miniasm fast assembler cannot produce accurate draft assemblies canu. suggest miniasm potentially used fast initial analysis polishing applied next step order produce higher-quality assemblies. discuss section polishing required improving accuracy low-quality draft assemblies. purpose aligning reads generated draft assembly bwa-mem minimap nanopolish racon perform polishing obtain improved assemblies discuss tools great detail since perform read mapping commonly analyzed relatively well understood minimap recently-released successor minimap. compare minimap bwa-mem minimap make observations. first minimap signiﬁcantly outperforms bwa-mem. since minimap produce alignments replace bwa-mem minimap future genome assembly pipelines. second minimap similar accuracy performance compared minimap. minimap minimap employ similar indexing seeding algorithms features minimap used pipeline analyze. result ﬁndings minimap generally remain minimap. nanopolish accepts mappings sequence alignment/map format works draft assemblies generated metrichor-basecalled reads. hand racon accepts pairwise mapping format mappings sam-format mappings requires input reads draft assembly ﬁles fastq format includes quality scores. however using parameter possible disable ﬁltering used racon requires quality scores. since basecalled reads fasta format experiments convert fasta ﬁles fastq ﬁles disable ﬁltering corresponding parameter. bwa-mem generates mappings format whereas minimap generates mappings format. since nanopolish requires format input generate mappings bwa-mem nanopolish polishing analysis. hand since racon accepts formats generate mappings overlaps bwa-mem minimap respectively racon polishing analysis. accuracy example nanopolish increases identity coverage draft assembly generated metrichor+minimap+miniasm pipeline respectively similarly racon increases respectively. bwa-mem racon metrichor metrichor minimap racon metrichor minimap miniasm+ bwa-mem racon metrichor minimap miniasm+ minimap racon bwa-mem racon nanonet nanonet minimap racon nanonet minimap miniasm+ bwa-mem racon nanonet racon minimap miniasm+ minimap bwa-mem racon scrappie scrappie minimap racon scrappie minimap miniasm+ bwa-mem racon scrappie minimap miniasm+ minimap racon bwa-mem racon nanocall nanocall minimap racon nanocall minimap miniasm+ bwa-mem racon nanocall minimap miniasm+ minimap racon bwa-mem racon deepnano deepnano minimap racon deepnano minimap miniasm+ bwa-mem racon deepnano minimap miniasm+ minimap racon bwa-mem racon metrichor metrichor minimap racon metrichor minimap miniasm bwa-mem racon metrichor minimap miniasm minimap racon bwa-mem racon nanonet nanonet minimap racon nanonet minimap miniasm bwa-mem racon minimap miniasm minimap nanonet racon bwa-mem racon scrappie scrappie minimap racon minimap miniasm bwa-mem racon scrappie scrappie minimap miniasm minimap racon bwa-mem racon nanocall nanocall minimap racon minimap miniasm bwa-mem racon nanocall nanocall minimap miniasm minimap racon bwa-mem racon deepnano deepnano minimap racon deepnano minimap miniasm bwa-mem racon deepnano minimap miniasm minimap racon wall clock time peak memory usage parallel speedup results obtained desktop big-mem systems. left column shows results desktop system right column shows results big-mem system. generated metrichor canu pipeline racon results identity coverage mismatches indels. minimap instead racon results identity coverage mismatches indels almost identical bwa-mem results. ﬁrst part performance analysis nanopolish divide draft assemblies kb-segments polish segments parallel threads segment. racon draft assembly polished using threads tool default divides input sequence windows length. table presents performance results nanopolish racon pipelines. based results make following observations. nanopolish runs take days complete whereas racon runs take minutes. mainly nanopolish works base individually whereas racon works windows. since window much longer single base computational workload greatly smaller racon. also racon uses mappings/overlaps polishing whereas nanopolish uses signal data hmmbased approach order generate consensus sequence computationally expensive. deeper performance analysis read mapping polishing tools perform scalability analysis read mapper polisher running desktop system big-mem system separately threads measuring performance metrics. figure shows speed memory usage parallel speedup bwa-mem minimap. make observations. desktop system minimap faster bwa-mem average big-mem system minimap faster bwa-mem average number threads smaller greater respectively. synchronization overhead increases number threads used minimap also show figure minimap’s speedup reduces number threads exceeds another indication synchronization overhead causes minimap slow down. usage increases linearly number threads minimap memory usage dependent hash table size independent number threads contrast bwamem thread separately performs computation different groups reads causes linear increase memory usage bwa-mem number threads increases. figure shows scalability results racon big-mem system. obtain results systems. however show results big-mem system since results systems similar. separately test tool using mappings mappings. based results make following observation. memory usage racon depends number mappings received fourth step since racon performs polishing using mappings. racon’s memory usage higher mode number mappings stored ﬁles greater number mappings stored ﬁles however using mappings mappings signiﬁcantly affect speed parallel speedup racon. figure shows scalability results nanopolish. test tool separately using segment length assess scalability tool respect segment length addition scalability respect number threads. measure performance metrics. show results big-mem system since results systems similar. based results make following observation. memory usage nanopolish affected number threads. however dependent segment length. nanopolish uses memory longer segments. segment length doubled increase memory usage greater ont’s basecalling tools metrichor nanonet scrappie best choices basecalling step terms accuracy performance. among tools scrappie newest fastest accurate basecaller. thus recommend using scrappie basecalling step read-to-read overlap ﬁnding step minimap faster graphmap requires memory. also similar accuracy graphmap. thus recommend minimap read-to-read overlap ﬁnding step assembly step execution time important concern recommend using canu since produces much accurate assemblies. however fast initial analysis recommend using miniasm since fast accuracy increased additional polishing step. miniasm used assembly deﬁnitely recommend polishing increase accuracy ﬁnal assembly even though polishing takes similar amount time miniasm canu accuracy improvements much smaller genome assembled using canu. hope future work improve performance polishing assembled genome already high accuracy reduce execution time overall assembly pipeline. future laptops become popular platform running genome assembly tools portability laptop makes good in-ﬁeld analysis. compared desktop server platforms test pipelines laptop even greater memory constraints lower computational power must factor limited battery life evaluating tools. based scalability studies perform using desktop server platforms would likely recommend using minimap followed miniasm assembly step minimap followed racon polishing step performing assembly laptop. three tools relatively amounts memory execute quickly expect would make tools good various constraints laptop. despite memory usage fast execution recommended pipeline produce high-quality assemblies suitable fast initial in-ﬁeld analyses. leave future work quantitatively study genome assembly pipeline using nanopore sequence data laptops mobile devices. choice language implement tool plays crucial role regarding overall performance tool. example although basecallers scrappie nanonet belong family scrappie signiﬁcantly faster nanonet since scrappie implemented whereas nanonet implemented python greatly affects performance usability tool. developing tools improving current ones developers aware memory hierarchy. data structure choices minimize memory requirements cache-efﬁcient algorithms positive impact overall performance tools. keeping memory usage check number threads enable usable tool also fast one. example graphmap cannot even memory usage nanopolish depends length segment number read mappings segment. segments memory usage also affects speed. nanopolish kb-segment faster kb-segment number threads exceeds number physical cores hyper-threading causes slowdown nanopolish cpu-intensive workload nanopolish resulting high contention shared resources threads executing core discuss observation summary. based observations make tools optional last steps pipeline conclude polishing signiﬁcantly increase accuracy assemblies. since bwamem nanopolish resource-intensive minimap racon pipelines minimap racon provide signiﬁcant speedup compared pipelines bwa-mem nanopolish resulting high-quality consensus sequences. based results collected observations made step genome assembly pipeline using nanopore sequence data associated tools make following major recommendations current future tool users. scalability tool number cores/threads important requirement. important make tool efﬁciently parallelized decrease overall runtime. design choices made wisely considering possible overheads parallelization add. example parallel speedup minimap reduces number threads reaches high number large increase overhead synchronization threads since parallelizing tool increase memory usage dividing input data batches limiting memory usage thread dividing computation instead dividing dataset simultaneous threads prevent large increases memory usage providing performance beneﬁts parallelization. example nanonet threads share computation read thus memory usage affected amount thread parallelism. result nanonet’s usability limited machines relatively larger memories analyze multiple steps associated state-of-the-art tools genome assembly pipeline using nanopore sequence data terms accuracy speed memory efﬁciency scalability. make four major conclusions based experimental analyses whole pipeline. first basecalling tools higher accuracy performance like scrappie overcome major drawback nanopore sequencing technology i.e. high error rates. second read-to-read overlap ﬁnding tools minimap graphmap perform similarly terms accuracy. however minimap performs better graphmap terms speed memory usage storing minimizers instead k-mers graphmap scalable running machines relatively small memories. third fast less accurate assembler miniasm used fast initial assembly polishing applied increase accuracy ﬁnal assembly. fourth state-of-the-art polishing tool racon generates high-quality consensus sequences providing signiﬁcant speedup another polishing tool nanopolish. hope believe observations analyses guide researchers practitioners make conscious effective choices deciding different tools step genome assembly pipeline using nanopore sequence data. also hope bottlenecks effects design choices found exposed help developers building tools improving current ones. knowledge ﬁrst work analyzes state-of-the-art tools associated step genome assembly pipeline using sequence data generated nanopore sequencing promising sequencing technology. leave future work quantitatively study tools different applications nanopore sequencing variant calling detection base modiﬁcations pathogen detection. show tradeoff accuracy performance choosing tool assembly step. miniasm coupled additional polishing step lead faster overall assembly using canu itself producing high-quality assemblies. thank jared simpson david matei feedback help questions tools. posters describing earlier stages work paper presented ismb-eccb thank poster session attendees feedback works. especially thank adam phillippy mile šiki´c feedback poster sessions. also thank developers nanonet racon answering questions github. work supported grant national institutes health o.m. c.a. installation grant european molecular biology organization c.a. gifts google intel samsung vmware. damla senol cali student department electrical computer engineering carnegie mellon university. research interests computational methods analysis nanopore sequencing data computer architecture. jeremie student department electrical computer engineering carnegie mellon university department computer science zürich. research interests computer architecture hardware accelerators bioinformatics applications. saugata ghose systems scientist department electrical computer engineering carnegie mellon university. research interests several aspects computer architecture signiﬁcant focus designing architecture-aware systems-aware memory storage. alkan assistant professor department computer engineering bilkent university. research interests combinatorial algorithms bioinformatics computational biology. onur mutlu professor department computer science zürich. also adjunct professor department electrical computer engineering carnegie mellon university. research interests computer architecture systems security bioinformatics.", "year": "2017"}