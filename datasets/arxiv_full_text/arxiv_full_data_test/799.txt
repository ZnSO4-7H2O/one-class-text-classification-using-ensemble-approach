{"title": "Fast Methods for Solving the Cluster Containment Problem for  Phylogenetic Networks", "tag": "q-bio", "abstract": " Genetic and comparative genomic studies indicate that extant genomes are more properly considered to be a fusion product of random mutations over generations and genomic material transfers between individuals of different lineages. This has motivated researchers to adopt phylogenetic networks and other general models to study genome evolution. One important problem arising from reconstruction and verification of phylogenetic networks is the cluster containment problem, namely determining whether or not a cluster of taxa is displayed in a phylogenetic network. In this work, a new upper bound for this NP-complete problem is established through an efficient reduction to the SAT problem. Two efficient (albeit exponential time) methods are also implemented. It is developed on the basis of generalization of the so-called reticulation-visible property of phylogenetic networks. ", "text": "genetic comparative genomic studies indicate extant genomes properly considered fusion product random mutations generations genomic material transfers individuals different lineages. motivated researchers adopt phylogenetic networks general models study genome evolution. important problem arising reconstruction veriﬁcation phylogenetic networks cluster containment problem namely determining whether cluster taxa displayed phylogenetic network. work upper bound np-complete problem established efﬁcient reduction problem. efﬁcient methods also implemented. developed basis generalization so-called reticulation-visible property phylogenetic networks. genome evolution shaped random mutations generations also horizontal genetic transfers individuals different species phylogenetic trees used study evolution life years. tree structure however powerful enough capture horizontal gene transfer hybridization genetic recombination events occur frequently viruses bacteria. researchers establish general evolutionary models including phylogenetic networks persistent homology investigate horizontal evolution phylogenetic network rooted acyclic graph internal nodes either indegree outdegree greater outdegree indegree greater one. latter called reticulations used model reticulation events. computational mathematical aspects phylogenetic networks extensively studied past decades hand phylogenetic networks useful dating inferring reticulation events hand extremely challenging reconstruct network models correctly sequence data gene trees given phylogenies numerous gene families species studied phylogenetic networks often reconstructed validated examining relationships existing gene trees well-established clades cluster containment problem tree containment problem thus arise study along lines. asks whether phylogenetic network displays phylogenetic tree whereas determining whether taxa cluster node phylogenetic tree displayed phylogenetic network. np-complete even several special subclasses binary phylogenetic networks recently good progress made investigations polynomial-time algorithms solving reticulation-visible networks interestingly decomposition technique introduced work visibility property lead linear-time algorithms reticulation-visible networks nearly stable networks well fast algorithms nonbinary networks note visibility property ﬁrst introduced huson coworkers study phylogenetic networks equivalence property appeared work lengauer tarjan analysis program optimization paper develop fast methods solving arbitrary networks. first using so-called small version namely determining whether network displays cluster given tree node derive surprisingly simple linear-time reduction problem. number nodes input network. mainly theoretically interesting large subexponential function. present practical methods. ﬁrst algorithm structurally simple. second designed small version sophisticated. basic concepts notations phylogenetic networks phylogenetic networks taxa acyclic rooted directed graphs root unique node indegree nodes outdegree labeled bijectively taxa node either indegree outdegree work simply call networks. network node tree node indegree one. note leaves tree nodes. sake convenience incoming edge open root make tree node. non-root node reticulation indegree greater outdegree one. reticulation said front child network leaf. note indegree reticulation might two. network binary every node total degree either three one. network denote root nodes edges nonleaf tree nodes reticulations leaves. fig. network leaves nontrivial tree components four trivial tree components {}{}{}{}. reticulation components reticulation incoming drawn solid arrow others dashed arrows. removing dashed edges network leads spanning subtree network tree node represents cluster whereas represents node visible leaf every path root contains node visible visible leaf invisible otherwise. note front reticulations visible network root visible every leaf. network deﬁned network node edge nodes edges digraph node edge tree components visibility network. removing reticulations yields forest connected component rooted subtree consisting tree nodes connected component forest called tree component similarly removing tree nodes yields forest connected component upside-down rooted subtree. connected component forest called reticulation component directed edge points root component component visible root visible leaf; invisible otherwise. note component rooted network root always visible. number invisible tree components network called invisibility number network. reticulation inner parents tree component cross otherwise. reticulation tree component reticulation parent reticulation component tree component contains reticulation cluster containment problem subset taxa called cluster. tree node subset labels mapped leaves subtree said cluster network displays cluster spanning subtree cluster networks formally deﬁned studies particularly convenient distinguish leaves simply coloring leaves blue rest red. becomes determine whether network leaves colored blue displays blue leaves. work version rest paper. assume exposed tree component displayed. therefore spanning tree exists cluster node cross reticulation select edge out. root since spans contains nodes consider following cases. blue leaves found implies none edges however cross reticulation contains exactly edge either fig. deﬁned eqn. respectively. here green incoming edges tree components front cross reticulations since visible blue leaf middle reticulation parent still modiﬁcation even words obtained replacing edge belonging selected edge entering since indegree reticulation remains also spanning subtree blue displays reticulation parent however incoming edge reticulation must edge blue deﬁned simple effective approach network leaves colored blue necessarily binary. lemma determining whether displays cluster consisting blue leaves done selecting exposed tree component recursively determining whether displayed either blue red. simple algorithm illustrated figure turns asymptotically better ﬁrst non-trivial algorithm developed showed analysis appendix note selected tree component visible leaves blue reticulation parent contains red) leaves found blue leaves replace blue leaf become front red) next step. contain reticulation blue leaf child colored leaves removed together edges entering resulting network denoted update). notation present ﬁrst algorithm appendix time complexity also analyzed. small cluster containment problem instance network colored leaves tree node question display cluster blue leaves instance part sccp assume tree node different network root. reason cluster displayed cluster displayed reticulation node displayed child. assume root tree component otherwise tree component construct network adding tree node edge entering reticulation node edge entering edge easy display soft clusters assumptions lead efﬁcient reduction problem another better algorithm. assume displays blue leaves spanning tree since spans contains nodes obtained removal edge entering tree component therefore becomes subtree implies either entirely disjoint subtree consisting vertices assumption root component. denote cluster vertex tree component ctb) comprises blue leaves nonempty. otherwise ctb) comprises leaves nonempty. therefore induces blue coloring tree components following properties tree component containing containing leaves must red. tree component parent blue contains edge tree-node another blue tree component similarly contains edge tree node tree component red. theorem sccp reduced networks linearly reduced problem sccp instance transformed instance contains variables number terms clause bounded plus maximum indegree reticulation node number tree components transformed -sat instance sccp upper bound ot.|r| ot.|r| using best derandomization sch¨oning’s algorithm known upper bound on.|r| practice implement computer program sccp sccp algorithm section work reduced networks. arbitrary network replace reticulation component non-binary reticulation node resulting network displays cluster original network displays technical lemmas sccp algorithm recursive procedure colors tree components bottom-up manner search coloring satisfying properties listed section step simplify current network either coloring least exposed tree component removing reticulation edges newly colored front reticulations different color contracting empty tree component fig. possible cases exposed tree component simpliﬁcation needed. visible. simpliﬁed switching leaves visible blue switching blue leaves otherwise. invisible adjacent tree component whose color status known. ﬁgure assumed visible blue leaves. simpliﬁed sending network leaf tree components blue keeping otherwise. recursively calling procedure coloring extension possible coloring extensions. sake presentation deﬁne following concepts notation tree components adjacent front reticulation parent tree components. example adjacent appearing figure adjacent tree components said neighbors other. exposed tree component child front reticulation step color nontrivial tree component blue sense blue leaves allowed added component. leaf detected blue tree component current coloring extension stop. furthermore leaf merged internal tree component unknown color status colored leaf’s color time. color tree component never changed assigned. importantly internal colored tree component necessarily contain leaf color color assigned execution algorithm. exposed tree component visible blue leaf colored blue algorithm. similarly exposed tree component visible leaf colored algorithm. therefore color status considered generalization visibility concept tree components study. assume tree components colored determine whether displayed not. partial coloring good displays spanning tree blue components ones whereas uncolored tree components sccp algorithm based following lemmas. selected exposed tree component color extension network derived input network step algorithm starts. consider whether visible whether neighbors colored order color simplify blue leaves lemma suggests exposed tree component visible blue leaves exposed tree component invisible tree component adjacent recall cross front reticulations unique child blue leaf. deﬁne blue) obtained removal edges words rblue) edges rred). true leaves front reticulations rred) merged whereas blue leaves rblue) merged red) deﬁned. lemma exposed tree component colored adjacent colored tree component partial coloring extended either red) proof. proof similar lemma fig. possible cases invisible exposed tree component recursive calls needed. blue leaves simplify keeping blue leaves switching leaves contract blue leaf making recursive call. simplify keeping leaves switching blue leave contract leaf making recursive call. here adjacent invisible tree component. leaves color. assume blue leaves shown here. consider cases separately. adjacent invisible tree component contract blue leaf making recursive call; blue switch blue leaves removing making recursive call. adjacent invisible tree components more keep blue leaves contracting blue leaf making recursive call; switch blue leaves removing making recursive call. lemma uncolored exposed tree component tree components partially colored deﬁned above. denote partial tree component coloring then following facts. proof. assume nonempty. rblue). then colored blue leaf child. thus blue child merged colored blue. similarly nonempty colored red. nonempty coloring good. lemma uncolored invisible exposed tree component tree components partially colored deﬁned above. denote partial coloring then following facts true binary network. |sb| |sr| extended either coloring blue components coloring components blue extended coloring blue switching blues make empty coloring blue extended coloring switching make empty coloring blue red. proof. pre-processing network topologically sorting tree components step step take constant time recursive call. exposed tree component edges leaving tree node outdegree implies front reticulations found adjacent |k|+ tree components. since exposed visibility done checking whether inner reticulation keep updating status cross reticulations step. therefore conditions checked using many basic set-arithmetic operations. total steps take basic set-arithmetic operations. number tree components uncolored algorithm starts. step executed working uncolored component either removed becomes colored step. consecutive executions step step algorithm execute series steps since different executions consider different tree components steps different neighbors step algorithm uses basic set-arithmetic operations consecutive executions steps total. execution steps create recursive calls simpliﬁed networks. summary denote worst-case time taken algorithm binary networks uncolored tree components. note color tree component remains unchanged assigned. assume selected tree component step. leaves colors found step executed. step least neighbor become colored blue similarly neighbor leaves color step executed. step colored whereas either removed colored color fig. performance comparison three methods random networks group method method method simple method presented section method method presented section remarks sccp algorithm presented appendix correct binary networks statements lemma hold arbitrary networks. such time complexity given theorem valid binary networks. arbitrary networks coloring settings neighbors selected component step step need revised; time complexity super-indegrees reticulation components minus number reticulation components. here super-indegree reticulation component deﬁned number tree components exists edge node reticulation validate methods implemented compared them well program reported random binary networks cluster cores. method methods presented sections called method respectively. time method largely depends number steps possible colorings tree component separately examined. branching number reﬂected exponential term time complexity used examine performances three methods. group network leaves reticulations; cluster three four leaves. group network eight leaves reticulations; cluster four leaves. group network leaves reticulations; cluster leaves.. performances three methods networks three groups showed similar trends. hence analyses group summarized figure analyses group group found supplementary figures validation tests suggests following facts method network branching number non-display case given cluster displayed much larger display case. such analyzed display non-display cases different ﬁgures. general branching number non-display case least times large display case. methods similar performance non-display cases. performance much worse method left bottom panel figure shows branching number method times fast many non-display cases. methods comparable performance display cases. method performed much better method hundreds display cases vice versa. performed signiﬁcantly better method reason performance method non-display case determines display cluster node node. since node branching number small estimated expected surpass method input network gets larger larger. also discover simple reduction sccp problem. allows develop practical sccp programs plugging popular solver minisat since reduction discovered compare method sat-solver based method. ﬁnal version. decomposition technique visibility property shown powerful solving arbitrary networks work applying techniques developed fast algorithms solving ccp. algorithms implemented validation test shows methods presented sections different advantages. former better non-display cases whereas latter better display cases. zhang would like thank dominik scheder discussions problems. work ﬁnancially supported singapore ministry education academic research fund tier grant bordewich semple reticulation-visible networks. adv. appl. math. cardona llabr´es rossell´o valiente metrics phylogenetic networks generalizations robinson-foulds iersel semple steel locating tree phylogenetic network. inf. process. lett. gambette gunawan labarre vialette zhang solving tree containment problem linear time nearly steel phylogeny discrete random processes evolution. siam philadelphia sz¨oll˝osi dav´ın tannier daubin boussau genome-scale phylogenetic analysis ﬁnds extensive gene transfer wang zhang zhang perfect phylogenetic networks recombination. comp. biol. weller linear-time tree containment phylogenetic networks. arxiv preprint arxiv. dong maximum likelihood inference reticulate evolutionary histories. proc. natl. acad. sci. input reduced network leaves colored blue number blue leaves; output true displays cluster consisting blue leaves false otherwise. update procedure contracts simpliﬁed tree component leaf is-b-display{ arbitrary reduced networks denotes invisibility number number invisible tree components. proof. step takes constant time. step takes input network simple ﬁnding exposed component compute non-trivial components topologically sorting following recursive steps exposed component taken sorted list components constant time. denote number tree nodes since tree node outdegree reticulations parents therefore condition steps veriﬁed basic set-arithmetic operations. step removal done deleting edges entering parent steps need remove certain edges entering front reticulations total steps take basic set-arithmetic operations. step remove network leaf property leaf implies network leaf path leaf implies invisible component therefore step step executed invisible exposed components examined. consecutive executions step algorithm execute series steps since certain edges entering front reticulations removed step different executions remove different components thus different edges algorithm uses basic set-arithmetic operations consecutive executions step total. appendix proof theorem theorem sccp networks linearly reduced problem sccp instance transformed instance contains variables number terms clause bounded maximum indegree reticulation node proof. consider sccp instance consisting network colored leaves tree component contains blue leaves node root tree component without loss generality assume reduced i.e. reticulation node consisting single reticulation node tree component said reachable ancestor nodes component. denote tree components tree components reachable also denote reticulations reachable tree component introduce variable reticulation components containing assume displays spanning then variable corresponding tree component assigned true component clauses eqn. clearly satisﬁable. consider reticulation parent child respectively unique path contains tree components containing thus corresponding variables take value true makes clauses deﬁned eqn. satisﬁable. contain tree components containing thus corresponding variables take value false. also makes clauses deﬁned eqn. satisﬁable. conversely assume truth assignment makes satisﬁable. consider tree component takes value true must path passes tree components whose corresponding variables take value true. assume hold. must reticulation tree component rooted child true tree components containing least parent false implying clause deﬁned eqn. false. contradiction. since tree component containing blue leaf takes value true subnetwork consisting tree nodes true components reticulation nodes spanning subtree roots contains blue leaves ones. shows displays blue leaves proof lemma visible blue leaf leaf suppose contrary displays spanning tree since spanning tree paths exist respectively. since visible must contain must thus belongs incomparable exposed. case belong contradiction. sufﬁciency clear subnetwork visible blue leaf since exposed either child inner front reticulation whose parents assume displays spanning tree thus thus unique path must contain every grandparent therefore must blue. similarly must thus must visible leaf. proof lemma assume |sb| +|sr| note color either blue red. colored blue every tree component uncolored rred then merge leaf front reticulation rred thus must colored red. similarly colored must color every tree component blue. assume colored either blue. invisible contain network leaf. moreover every reticulation must cross front reticulation must neighbor means every reticulation rblue) leaf colored blue remove every reticulation makes labeled leaf edges colored must color blue blue leaves hence holds. input binary network blue leaves root tree component output true displays cluster consisting blue leaves false otherwise. color status tree component value blue is-b-display component containing blue tree components red; select exposed tree component fig. illustration algorithm section left panel contains input network recursive step ﬁrst selected example. since visible blue leaves shall keep blue leaves switch leaves obtain blue updated middle network. recursive step selected. since invisible consider possible cases blue leaves kept resulting right network updating; leaves kept resulting right bottom network updating. recursive step consider networks one. cluster blue leaves displayed right network displayed right bottom network. fig. performance comparison three methods random networks group method method method simple method presented section method method presented section fig. performance comparison three methods random networks group method method method simple method presented section method method presented section", "year": "2018"}