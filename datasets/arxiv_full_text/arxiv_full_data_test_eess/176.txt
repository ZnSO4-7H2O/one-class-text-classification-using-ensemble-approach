{"title": "Fast-SSC-Flip Decoding of Polar Codes", "tag": "eess", "abstract": " Polar codes are widely considered as one of the most exciting recent discoveries in channel coding. For short to moderate block lengths, their error-correction performance under list decoding can outperform that of other modern error-correcting codes. However, high-speed list-based decoders with moderate complexity are challenging to implement. Successive-cancellation (SC)-flip decoding was shown to be capable of a competitive error-correction performance compared to that of list decoding with a small list size, at a fraction of the complexity, but suffers from a variable execution time and a higher worst-case latency. In this work, we show how to modify the state-of-the-art high-speed SC decoding algorithm to incorporate the SC-flip ideas. The algorithmic improvements are presented as well as average execution-time results tailored to a hardware implementation. The results show that the proposed fast-SSC-flip algorithm has a decoding speed close to an order of magnitude better than the previous works while retaining a comparable error-correction performance. ", "text": "abstract—polar codes widely considered exciting recent discoveries channel coding. short moderate block lengths error-correction performance list decoding outperform modern errorcorrecting codes. however high-speed list-based decoders moderate complexity challenging implement. successivecancellation -ﬂip decoding shown capable competitive error-correction performance compared list decoding small list size fraction complexity suﬀers variable execution time higher worstcase latency. work show modify stateof-the-art high-speed decoding algorithm incorporate sc-ﬂip ideas. algorithmic improvements presented well average execution-time results tailored hardware implementation. results show proposed fast-ssc-ﬂip algorithm decoding speed close order magnitude better previous works retaining comparable error-correction performance. polar codes made gpp’s next-generation mobilecommunication standard excellent errorcorrection performance successive-cancellation list decoding however implementing high-throughput decoders retaining moderate complexity challenging since decoder speculatively explores multiple candidate solutions parallel majority abandoned. alternative aﬁsiadis proposed low-complexity successive-cancellation decoding algorithm explores candidate solutions sequentially therefore avoiding many unnecessary computations. showed that -bit polar code code rate -bit cyclic redundancy check could match error-correction performance decoding small list size suﬃcient number trials attempted however sequential nature instantaneous decoding throughput decoding variable average throughput depends channel signalto-noise ratio. nevertheless shown that reasonable conditions much better average throughput signiﬁcantly lower average decoding complexity terms area-time product decoding. decoding algorithm errorshow correction performance either virtually close original algorithm. hardware implementation considerations discussed execution time proposed algorithm compared scf-decoder implementation literature. outline remainder paper starts section provides background polar-code construction encoding polar-code representations decomposition constituent codes decoding algorithms work built. section describes proposed algorithm decision-llr equations various constituent-code types. hardware considerations discussed section average execution-time comparison state also presented. finally section concludes paper. polar codes linear block codes i.e. encoding process implies linear transformation vector bits. transformation structured results polarization eﬀect length tends inﬁnity encoded bits decoded perfectly others become completely unreliable. vector bits encoded kronecker product obtain polar code rate most-reliable locations hold information bits bits called frozen bits predetermined value bit-location reliabilities depend channel type condition. many methods proposed calculate reliabilities; vardy contributions paper show merge decoding algorithm state-of-the-art high-speed successive-cancellation -based decoding algorithm decomposes polar codes constituent codes. introduce decision-log-likelihood-ratio calculations required decoding tailored various constituent-code types. addition matrix form polar codes represented graph. fig. shows representation polar code modulo- additions grayed ui’s hold frozen bits black ui’s hold information bits. encoding done propagating vector graph left right. also fig. notice polar codes built recursively ﬁrst half polar code length result element-wise modulo addition polar codes length half corresponds second polar code length words polar code length seen composition smaller constituent codes length information bits. taking consideration frozen-bit locations many constituent codes considered block codes special structure rather polar codes. brieﬂy reminded section ii-c below structure exploited dedicated decoding algorithms eﬃcient generic decoding algorithm polar codes. alternatively graph representation shown polar codes also represented binary trees decoder trees white black leaf nodes correspond frozen-bit information-bit locations respectively. fig.b shows decoder tree representation polar code illustrated graph fig. part graph circled green dashed line fig. corresponds node width circled fig. bit-estimate vector generated left sibling decoder-tree. left sibling leaf node estimated-bit value used otherwise estimedbit vector node calculated alamdar-yazdi kschischang proposed simpliﬁed algorithm subtrees solely composed either frozen information nodes fully traversed recognizing types constituent codes specialized algorithms corresponding dedicated decoders proposed algorithm described later extended referred fastssc algorithm. details specialized algorithms fastssc used paper provided alongside proposed algorithm section below. fast-ssc decoders throughput depend frozen-bit locations however typically order magnitude higher sc-based decoders. fig. shows decoder tree polar code fast-ssc algorithm applied i.e. tree pruned recognizing left-hand-side subtree fig. corresponds node right-hand-side subtree single-parity-check node. fig. former subtree replaced purple-striped node latter orange-hatched node. decoding algorithm initially proposed proceeds visiting decoder-tree representation—e.g. fig. b—sequentially bottom left right successively estimating leaf nodes noisy channel values. visiting left edge representation algorithm calculate soft-input llrs child node min-sum approximation decoding algorithm builds upon slightlymodiﬁed decoding algorithm. starts going regular sc-decoding pass parallel decoding process list decision llrs associated estimated information built. decoding completed embedded veriﬁed. case matches decoding stops estimated codeword output. otherwise another sc-decoding pass launched however time location information corresponds least-reliable decision reached estimated ﬂipped resuming decoding. decoding completed veriﬁed again. matches estimated codeword output otherwise process restarted corresponding second-least-reliable decision ﬂipped. latency underlying decoder. furthermore average worst-case throughput functions throughput decoder. thus improving speed underlying decoder also improves throughput decoder. ﬁrst trial decoding algorithm builds list contains decision llrs corresponding list used determine information bits. information subsequent trials. following show fast-ssc algorithms merged. fast-ssc algorithm uses dedicated decoders estimate multiple information bits time. decoders need modiﬁed calculate decision llrs required algorithm support bit-ﬂipping procedure. modiﬁcations described following subsections essential leaf-node types contain information bits. leaf-node types encountered expressed node combinations include types covered below. information nodes length contain information bits none locations frozen. decoding hard decision node soft-input llrs αnv− parity bits involved calculation decision llrs remains original algorithm i.e. absolute value repetition nodes protect single information repeating times encoding time. thus fast-ssc decoding takes hard decision node input llrs. decision original algorithm uses absolute value corresponds information bit. repetition node fastssc algorithms eﬀectively calculate node input llrs. thus proposed decision calculated deﬁne birepetition node node locations frozen exception mostsigniﬁcant positions carry information bits original fast-ssc algorithm birepetition codes length decoded node whereas longer birepetition codes decomposed. shown eﬃciently decoded recognizing similarity repetition nodes i.e. eﬃciently decoded independent repetition codes. ﬁrst repetition code composed even-indexed locations second odd-indexed locations. therefore decision-llr calculations nodes special type polar codes frozen ﬁrst location. maximum-likelihood decoding algorithm codes single estimated-bit vector retained summarized ﬂipping information corresponds least-reliable input parity-check satisﬁed challenge adapt type node decoding calculate complexity meaningful alternative decision llrs take account parity constraint. calculating exact decision llrs original algorithm would involved many calculations. thus propose approximation similar detection metric update rule nodes proposed deﬁne decision llrs approximations decision llrs incur errorcorrection performance loss. shown next section loss partially compensated using scaling factor importantly becomes negligible maximum number trials tmax increased. fig. also shows that simulated polar code error-correction performance decoding vicinity decoding list size note recent work decoding proposes low-complexity method orthogonal work error-correction performance low-rate polar codes length shown improve approximately list decision llrs kept sorted insert-sort unit running parallel decoding process capable handling maximum input llrs maximum number llrs specialized decoders simultaneously access memory. keeping list sorted size constrained tmax thus memory bits suﬃcient store decision-llr list number quantization bits used represent decision llrs. alongside list corresponding indices requires memory starting implementation fast-ssc algorithm described unit—an unrolled generic decoder length--only birepetition codes—would replaced second copy unit implementing repetition node order implement birepetition node. tmax unit would need sorter retain tmax smallest decision llrs. bit-ﬂipping circuitry needs added units handling information bits. modiﬁcations expected little impact critical path even involved modiﬁcations appends ﬂips remainder calculations occur parallel. latency fast-ssc algorithm cannot expressed compact closed form heavily depends frozen-bit locations node types constraints. however numerical evaluations show roughly order magnitude lower decoding relevant code rates. fig. error-correction performance comparison polar code decoded using various -bit crc-aided scf-based algorithms tmax tmax curves -bit crc-aided decoding included reference. simultaneously parity constraint remain satisﬁed. cases distinguished. iﬂip denote location initial ﬂipped imin imin correspond indices leastsecond-least-reliable input llrs respectively. iﬂip imin iﬂip imin ﬂipped otherwise iﬂip imin ﬂipped. fig. compares error-correction performance terms frame-error rate decoding algorithm original algorithm proposed tmax maximum number trials. curve algorithm nodes used also included reference. without nodes codes length decomposed length- repetition code combined length- rate- code. longer codes generate chain rate-r rate- nodes terminate length- repetition code combined length- rate- code. short polar code used -bit representative could used next-generation mobile-communication systems reference ﬁgure also shows -bit crc-aided decoding list sizes simulation results bpsk-modulated random codewords transmitted awgn channel. performance close original algorithm. ingredients decision-llr calculations bit-ﬂipping procedures introduced decoding multi-bit dedicated decoders used fast-ssc algorithm. proposed decoding algorithm promising applications handle variable execution time. errorcorrection performance match list-based decoding small list speed tends fastest lowcomplexity decoders practical operating conditions.", "year": "2017"}