{"title": "Solving Relational MDPs with Exogenous Events and Additive Rewards", "tag": ["cs.AI", "cs.LG"], "abstract": "We formalize a simple but natural subclass of service domains for relational planning problems with object-centered, independent exogenous events and additive rewards capturing, for example, problems in inventory control. Focusing on this subclass, we present a new symbolic planning algorithm which is the first algorithm that has explicit performance guarantees for relational MDPs with exogenous events. In particular, under some technical conditions, our planning algorithm provides a monotonic lower bound on the optimal value function. To support this algorithm we present novel evaluation and reduction techniques for generalized first order decision diagrams, a knowledge representation for real-valued functions over relational world states. Our planning algorithm uses a set of focus states, which serves as a training set, to simplify and approximate the symbolic solution, and can thus be seen to perform learning for planning. A preliminary experimental evaluation demonstrates the validity of our approach.", "text": "abstract. formalize simple natural subclass service domains relational planning problems object-centered independent exogenous events additive rewards capturing example problems inventory control. focusing subclass present symbolic planning algorithm ﬁrst algorithm explicit performance guarantees relational mdps exogenous events. particular technical conditions planning algorithm provides monotonic lower bound optimal value function. support algorithm present novel evaluation reduction techniques generalized ﬁrst order decision diagrams knowledge representation realvalued functions relational world states. planning algorithm uses focus states serves training simplify approximate symbolic solution thus seen perform learning planning. preliminary experimental evaluation demonstrates validity approach. relational markov decision processes offer attractive formalism study reinforcement learning probabilistic planning relational domains. however work rmdps focused planning learning transitions world result agent’s actions. interested class problems modeled service domains world affected exogenous service requests addition agent’s actions. paper inventory control domain motivating running example experimental validation. domain models retail company faced task maintaining inventory shops meet consumer demand. exogenous events correspond arrival customers shops point time number service requests occur independently independently agent’s action. although focus independent exogenous service requests common many problems example emergency response trafﬁc control service centers taxicab companies hospitals restaurants. exogenous events present challenge planning reinforcement learning algorithms number possible next states stochastic branching factor grows exponentially number possible simultaneous service requests. paper consider symbolic dynamic programming solve rmdps allows reason abstractly typical forward planning reinforcement learning. solutions propositional mdps adapted rmdps grounding rmdp size propositional encoding using factored approach solve resulting planning problem e.g. using algebraic decision diagrams linear function approximation approach easily model exogenous events plans ﬁxed domain size requires increased time space grounding. relational approach provides solution independent domain size i.e. holds problem instance. hand exogenous events make ﬁrst order formulation much complex. knowledge work approached sanner’s work ambitious attempted solve general class problems solution used linear function approximation approximate policy iteration heuristic logical simpliﬁcation steps demonstrate problems solved clear combination ideas work applicable terms algorithmic approximations terms symbolic simpliﬁcation algorithms. paper make different compromise constraining class problems aiming complete symbolic solution. particular introduce class service domains simple form independent object-focused exogenous events transition step modeled ﬁrst taking agent’s action following sequence exogenous actions order. investigate relational approach solve problems. main contribution paper symbolic algorithm proved provide lower bound approximation true value function service domains certain technical assumptions. assumptions somewhat strong allow provide ﬁrst complete analysis relational exogenous events important understanding problems. addition assumptions needed analysis needed algorithm applied general settings. second main contribution provides algorithmic support implement algorithm using gfodd representation gfodds provide scheme capturing manipulating functions relational structures. previous work analyzed theoretical properties representation provide practical algorithms. paper develop model evaluation algorithm gfodds inspired variable elimination model checking reduction gfodds. crucial efﬁcient realization approximate algorithm. illustrate algorithm variants domain satisﬁes assumptions not. results demonstrate algorithm implemented efﬁciently size-independent solution scales much better propositional approaches produces high quality policies. assume familiarity basic notions markov decision processes first order logic brieﬂy given states actions transition function immediate reward function discount factor solution policy maximizes expected discounted total reward obtained following policy starting state. value iteration algorithm relational mdps relational mdps simply mdps states actions described function-free ﬁrst order logical language. particular language allows logical constants logical variables predicates functions arity greater state corresponds interpretation ﬁrst order logic speciﬁes ﬁnite domain elements also known objects mapping constants domain elements truth values predicates tuples domain elements appropriate size atoms predicates applied appropriate tuples arguments. atom said ground arguments constants domain elements. example using notation empty atom empty ground atom involving predicate empty object shop notation distinguish constants variables clear context. advantages relational algorithms including paper number objects known used planning time resulting policies generalize across domain sizes. state transitions induced agent actions modeled exactly previous work agent action types parametrized tuple objects yield action template concrete ground action concrete action unload). simplify notation refer single variable tuple variables appropriate arity. agent action ﬁnite number action variants user performs state variants chosen randomly using state-dependent action choice distribution r|a). similar previous work model reward additive function domain. avoid technical complications average instead reward function; yields result multiplicative factor. relational expressions gfodds implement planning algorithms relational mdps require symbolic representation functions compactly describe rewards transitions eventually value functions. paper gfodd representation ideas work representation express open-expressions closed expressions interpretations expression represents function mapping interpretations real values. open expression similar open formula ﬁrst order logic evaluated interpretation substitute variables concrete objects closed expression much like closed ﬁrst order logic formula aggregates value possible substitutions objects first order logic limits values provides aggregation used individually variable expressions general allowing additional aggregation functions aggregation generalizes quantiﬁcation logic allowing take numerical values. hand expressions require aggregation operators front formulas thus correspond logical expressions prenex normal form. enables treat aggregation portion formula portion separately algorithms. paper focus average aggregation. example domain might expression maxt avgs else else intuitively awards non-empty shop shop awarded truck shop. value expression given picking maximizes average gfodds provide graphical representation associated algorithms represent open closed expressions. gfodd given aggregation function exactly expressions labeled directed acyclic graph represents open formula portion expression. leaf gfodd labeled non-negative numerical value internal node labeled ﬁrst-order atom allow atoms constants variables arguments. propositional diagrams efﬁciency reasons order nodes diagram must conform ﬁxed ordering node labels ﬁrst order atoms case. figure shows example gfodd capturing expression given previous paragraph. given diagram interpretation substitution variables objects traverse path leaf gives value substitution. values substitutions aggregated exactly expressions. particular variables ordered aggregation function calculate ﬁnal value mapb semantics prescribes enumerate substitutions variables {xi} objects perform aggregation variables going therefore think aggregation organizes substitutions blocks aggregates value block separately repeating call algorithm follows deﬁnition directly brute force evaluation. detailed example shown figure evaluate diagram figure interpretation shown enumerate substitutions objects variables obtain value each aggregate values. block varies values aggregated value done every block aggregate substitutions ﬁnal value case binary operation real values generalized open closed expressions natural way. closed expressions represents function maps interpretation follow general convention using denote respectively applied expressions. provides deﬁnition implementation binary operations expressions. work showed binary operation safe i.e. distributes respect aggregation operators simple algorithm implementing binary operation expressions. example safe w.r.t. aggregation easy maxx maxy open formula portion result fig. dynamics regression example gfodd. empty deterministic action unload. regressing gfodd unload. object maximization. diagrams throughout paper left-going edges represent true branch node right-going edges represent false branch. calculated directly open expressions apply procedure calculates diagram representing using operations graphs representing note need standardize apart renaming operations. relational mdps provides symbolic implementation value iteration update avoids state enumeration implicit equation. algorithm generalizing calculates iteration value iteration follows. input closed expressions reward example below) open expressions probabilistic choice actions r|a) dynamics deterministic action variants. action dynamics speciﬁed providing diagram variant predicate template corresponding open expression speciﬁes truth value next state executed current state. figure shows unload predicates empty. note contrast representations planning operators tvds specify truth value action change truth value. since unload deterministic variant r|a) illustrate probabilistic actions next section. following require r|a) aggregations cannot introduce variables ﬁrst refers second variables. implies regression product terms algorithm change aggregation function therefore enables analysis algorithm. regression step-to-go value function regressed every deterministic variant every action produce regr). regression conceptually similar goal regression deterministic planning needs done paths diagram thought goal planning context. done efﬁciently replacing every atom open formula portion corresponding without changing aggregation function. figure illustrates process block replacement diagram part note affected action. therefore tvds simply repeats predicate value corresponding node unchanged block replacement. therefore example effectively replacing node tvd. leaf valued connected left child node leaf connected right child maintain diagrams sorted must fact different implementation block replacement; implementation affect constructions proofs paper therefore refer reader details. regr))] action generated combining regressed diagrams using binary operations expressions. recall probability diagrams refer additional variables. multiplication therefore done directly open formulas without changing aggregation function. argued guarantee correctness summation steps must standardize apart functions adding them. produce action thus obtaining value achievable best ground instantiation state. step implemented converting action parameters variables associated aggregation operator appending operators head aggregation function. example object maximization applied diagram figure would replaced variables given aggregation aggregation shown part ﬁgure. therefore step constants referring concrete objects world step turn variables specify aggregation function them. main advantage approach regression operation binary operations expressions performed symbolically therefore ﬁnal value function output algorithm closed expression language. therefore completely symbolic form value iteration. several instantiations idea implemented except work previous work handled aggregation. previous work relies fact binary operations safe respect aggregation provide gfodd based algorithm problems reward function aggregations paper reward functions aggregation. binary operations safe respect binary operation not. example avg{ avg{ max{ avg{ avg{max{ max{ max{ address issue introduce implementation case next section. proceed describe extensions handle exogenous events. exogenous events refer spontaneous changes state without agent action. main modeling assumption denoted object-centered exogenous actions automatically taken every time step. particular every object domain action acts object conditions effects mutually non-interfering given state actions applied simultaneously equivalent sequential application order. gfodd action representation described previous section capture dynamics example domain. simple version inventory control domain running example experimental results. objects depot truck number shops. shop empty full i.e. inventory levels truck either depot shop. reward fraction non-empty shops. agent actions deterministic capture stock replacement. particular shop ﬁlled unloading inventory truck step. truck loaded depot driven location location step. exogenous action variants; success variant esucc occurs probability fail variant occurs probability figure parts illustrate model gfodd representation. order facilitate presentation algorithmic steps figure shows slightly different reward function used reward running example. analysis make modeling assumptions. assume exogenous action affect unary properties object simplify presentation consider single predicate affected number predicates handled. special predicate empty specifying whether shop empty. assume appear precondition agent action. follows affects appear precondition cannot appear precondition action. fig. representation template method empty action variant esucc. empty action variant ail. specialized form simply value therefore gfodd given single leaf node. r|e) simply value simple reward function. grounding using skolem constant regressing esucc multiplying probability diagram regressing multiplying probability diagram. adding without standardizing apart. reintroducing aggregation. complex expressions require counting formulas domain possible simple approach would explicitly calculate composition agent’s actions exogenous events. assumes know number objects results exponential number action variants makes infeasible. second simple approach would directly modify algorithm sequentially regresses value function ground exogenous actions performing regression agent actions correct assumptions. however approach requires know effectively grounds solution suffers terms generality. next describe template method main contributions provides completely abstract approximate solution exogenous event model. make ﬁnal assumption reward function closed expression form maxx avgyv variables single variable predicate appears instantiated domain described satisﬁes assumptions. grounding skolem constant partially ground maxx regression function regressed every deterministic variant exogenous action centered produce regr). action variants value function regr)) updated. multiplication done directly open formulas without changing aggregation function. importantly contrast standardize apart functions performing leads approximation. lifting output previous step maxx return maxx avgyw thus algorithm grounds using generic object exogenous actions performs regression single generic exogenous action reintroduces aggregation. figure parts illustrate process. proof. main idea proof show that assumptions result algorithm equivalent sequential regression exogenous actions step action variants standardized apart. recall input value function form maxx avgyv establish relationship show maxx sequential algorithm regresses intermediate value function form maxx ﬁrst portions change structural manner diagram remaining portions retain original form addition result regressing form calculated step template method. therefore regressed result maxx avgyw result template method. sequential algorithm correct deﬁnition standardizing apart yields lower bound standardizing apart. true functions maxx] maxx avgy+f last equality +avgy holds range objects. therefore results regression different variants step adding without standardizing apart last equation yields lower bound. lemma requires used input satisﬁes holds reward function maintains property holds inductively together implies template method provides lower bound true bellman backup. therefore remains show implemented maxx avgy aggregation maintains form first consider regression. assumption holds algorithm using regression tvds introduce occurrences regression also change aggregation function. similarly probability diagrams introduce change aggregation function. therefore maintained steps. steps need discuss binary operations max. maxx maxx therefore sufﬁces standardize apart portion left intact maintained. finally recall need implementation binary operation aggregation. done follows perform max{]} introduce variables else clearly correct whenever interpretation least objects unconstrained. branches statement mutually exclusive expression simpliﬁed maxzz maxx avgy else implementation uses equality node root label hangs true false branches. crucially need standardize apart representation thus maintained. establishes approximation returned algorithm lower bound true bellman backup additional argument shows monotonic lower bound true bellman backup. well known holds value greedy policy w.r.t. least signiﬁcance therefore provides immediate certiﬁcate quality resulting greedy policy. recall approximate backup have theorem assumptions hold reward function nonnegative mentioned above although assumptions required analysis algorithm applied widely. assumptions provide basic modeling assumption object centered exogenous events additive rewards. easy generalize algorithm events rewards based object tuples instead single objects. similarly proof fails violated algorithm applied directly without modiﬁcation. hold appear multiple arguments algorithm needs modiﬁed. implementation introduces additional approximation iteration boundary unify arguments average variable algorithm applied inductively extensions algorithm demonstrated experiments. relation straight line plans template method provides symbolic calculate lower bound value function. interesting consider kind lower bound provides. recall straight line plan approximation calculate policy instead state seeks best linear plan highest expected reward. next observation argues template method provides related approximation. note however unlike previous work straight line plans computation done symbolically calculates approximation start states simultaneously. observation template method provides approximation related value best straight line plan. deterministic agent action template exactly value straight line plan. otherwise approximation bounded value straight line plan optimal value. symbolic operations algorithm yield diagrams redundant sense portions removed without changing values compute. recently introduced idea model checking reductions compress diagrams. basic idea simple. given focus states evaluate diagram every interpretation portion diagram contribute ﬁnal value interpretations removed. result diagram exact focus states approximate states. refer reader motivation justiﬁcation. work several variants idea analyzed formally shown perform well empirically methods generating random walks developed. section develop second contribution paper providing efﬁcient realization idea maxx avgy aggregation. basic reduction algorithm refer brute force model checking gfodds evaluate diagram example focus marking edges actively participate generating ﬁnal value returned example. maxx avgy value given winner aggregation. block substitutions includes assignment possible assignments block collect edges traversed substitutions block. picking block also collect edges traversed block breaking ties lexicographic ordering edge sets. take union marked edges examples connecting edge consider example evaluation figure assigned node identiﬁers identify edges parent node branch leftgoing edge root edge case ﬁnal value achieved multiple blocks substitutions distinct sets edges assuming lexicographically smaller chosen marked set. process illustrated tables figure referring reduction procedure focus includes interpretation edges redirected value efﬁcient model evaluation reduction show process evaluation reduction implemented efﬁciently. idea taking inspiration variable elimination aggregate values early calculating tables. however problem complex standard variable elimination require recursive computation diagram. every node n.lit literal node false true branches respectively. deﬁne above variables appearing self variables maxabove maxself variables largest index above self respectively. finally maxvar maximum maxabove maxself figure shows maxvar maxabove example diagram. given interpretation bln↓t bindings objects variables similarly bln↓f bindings sets obviously disjoint together cover bindings example root node diagram figure bln↓t table mapping bln↓f table mapping evaluation procedure eval follows note several improvements algorithm application reductions applicable used experiments. implement recursive code using dynamic programming avoid redundant calls. aggregation operator idempotent i.e. op{a aggregation implicit variables change table implementation simpliﬁed. holds aggregation. case maxx avgy aggregation procedure made efﬁcient noting that within variables aggregation done order. therefore aggregated variable appear node aggregated recursive algorithm extended collect edge sets winning blocks associating table entries. leaf nodes empty edge sets. join step node adds corresponding edge entry. finally aggregating average variable take union edges aggregating variable take edges corresponding winning value breaking ties favor lexicographically smaller edges. detailed example algorithm given figure evaluation interpretation part node ﬁrst collects table that used above already aggregates join step node uses entries left child entries right child. node collects entries aggregates even though appears above. node similarly collects combines tables aggregates next theorem proved induction structure gfodd theorem value block returned modiﬁed eval procedure identical ones returned brute force method. section present empirical demonstration algorithms. implemented algorithms prolog extension fodd-planner compared spudd madcap take advantage propositionally factored state spaces implement using propositional algebraic decision diagrams afﬁne adds respectively. spudd madcap domains speciﬁed relational domain description language translated propositional descriptions using software provided ippc planning competition experiments intel core quad .ghz. system given memory spudd madcap given tested three systems domain described shops trucks binary inventory levels present results domain satisﬁes assumptions propositional systems fare better case. also present results complex domain inventory levels shop consumption rates satisfy assumption experiments show even small extension combinatorics render propositional approach infeasible. cases constructed focus states include possible states shops. provides exact reduction states shops reduction approximate larger states experiments. figure summarizes results discuss left right bottom. left plot shows runtime function iterations illustrates variable elimination method signiﬁcantly faster brute force evaluation enables many iterations. right plot shows total time systems problem instance size aic. spudd runs memory fails shops madcap handle middle plots show cost using policies on-line execution time function increasing domain size test instances. control time policies show time gfodd policy produced iterations sufﬁcient solve problem aic. on-line time propositional systems fast domain sizes solve system solve problems much larger size bottom plots show total discounted reward accumulated system randomly generated problem instances averaged runs. cases algorithms signiﬁcantly better random policy. approximate policy distinguishable optimal propositional policies slightly better summary system provides non-trivial approximate policy sub-optimal cases especially violated. hand ofﬂine planning time independent domain size solve instances cannot solved propositional systems. paper presents service domains abstraction planning problems additive rewards multiple simultaneous independent exogenous events. provide relational algorithm ﬁrst complete analysis algorithm provable guarantees. particular algorithm template method guaranteed provide monotonic lower bound true value function technical conditions. also shown lower bound lies value straight line plans true value function. second contribution introduce evaluation reduction algorithms gfodd representation turn facilitate efﬁcient implementation algorithm. preliminary experiments demonstrate viability approach algorithm applied even situations violate assumptions used analysis. paper provides ﬁrst step toward analysis solutions general problems exogenous events focusing well deﬁned subset models. identifying general conditions existence compact solutions representations solutions associated algorithms important challenge future work. addition problems involved evaluation application diagrams computationally demanding. techniques speed computations important challenge future work. system achieve structural convergence reductions comprehensive. give results iterations sufﬁcient solving problems domain. iterations policies larger execution slower.", "year": 2013}