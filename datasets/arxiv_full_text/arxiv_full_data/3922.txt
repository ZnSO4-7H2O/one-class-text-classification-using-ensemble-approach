{"title": "Scalability of Genetic Programming and Probabilistic Incremental Program  Evolution", "tag": ["cs.NE", "cs.AI", "I.2.8; I.2.6; G.1.6"], "abstract": "This paper discusses scalability of standard genetic programming (GP) and the probabilistic incremental program evolution (PIPE). To investigate the need for both effective mixing and linkage learning, two test problems are considered: ORDER problem, which is rather easy for any recombination-based GP, and TRAP or the deceptive trap problem, which requires the algorithm to learn interactions among subsets of terminals. The scalability results show that both GP and PIPE scale up polynomially with problem size on the simple ORDER problem, but they both scale up exponentially on the deceptive problem. This indicates that while standard recombination is sufficient when no interactions need to be considered, for some problems linkage learning is necessary. These results are in agreement with the lessons learned in the domain of binary-string genetic algorithms (GAs). Furthermore, the paper investigates the effects of introducing utnnecessary and irrelevant primitives on the performance of GP and PIPE.", "text": "abstract paper discusses scalability standard genetic programming probabilistic incremental program evolution investigate need eﬀective mixing linkage learning test problems considered order problem rather easy recombinationbased trap deceptive trap problem requires algorithm learn interactions among subsets terminals. scalability results show pipe scale polynomially problem size simple order problem scale exponentially deceptive problem. indicates standard recombination suﬃcient interactions need considered problems linkage learning necessary. results agreement lessons learned domain binary-string genetic algorithms furthermore paper investigates eﬀects introducing unnecessary irrelevant primitives performance pipe. genetic programming holds simple approaches using probabilistic recombination within estimation distribution algorithm framework probabilistic incremental program evolution purpose paper study scalability standard pipe decomposable problems order trap. algorithms perform expected solve order scalably failing scale trap. additionally paper studies eﬀects introducing unnecessary irrelevant primitives. pipe shown deal sources diﬃculty well. results presented paper conﬁrm binary-string common pipe thus lessons learned design study application standard extensions carry argued example paper starts describing algorithms investigated paper pipe. section explains test problems. section provides discusses experimental results. section presents important topics future work line research. section summarizes paper. finally section concludes paper. methods pipe work programs encoded labeledtree structures applied class problems. generates candidate programs using standard variation operators crossover mutation pipe builds samples probabilistic model form tree mutually independent nodes. therefore diﬀerence pipe variation operator genetic programming genetic programming genetic algorithm evolves programs instead ﬁxed-length strings. programs represented trees nodes represent starts population random candidate programs. program evaluated given task ﬁtness value assigned. population promising programs selected using standard selection operators tournament truncation selection. selected programs directly copied population remaining ones copied applying variation operators crossover mutation. crossover usually proceeds exchanging randomly selected subtrees programs whereas mutation usually replaces randomly selected subtree program randomly generated one. process repeated termination criteria met. since standard variation operators proceed without considering interactions diﬀerent components selected programs likely experience diﬃculties solving problems diﬀerent program components interact strongly. however problems decomposed subproblems order easy standard based recombination. intuition veriﬁed experiments section similar behavior observed gas; standard variation operators work great problems interactions decision variables often fail problems highly interacting decision variables pipe probabilistic incremental program evolution algorithm computer programs mathematical expressions evolved like however pairwise crossover mutation replaced building probalike pipe represents programs labeled trees internal node represents function leaf represents variable constant. initial population also generated random. programs population evaluated selection applied select population promising programs. instead applying crossover mutation part selected population generate programs pipe builds probabilistic model selected programs form tree. probabilistic model sampled generate candidate programs form population. process repeated termination criteria met. learning probabilistic model probabilistic model pipe tree structure corresponding structure candidate programs. since diﬀerent programs diﬀerent structure size population ﬁrst parsed smallest tree contains every structure selected population. node program selected population directly corresponds node model whereas children internal node represent arguments function node. figure illustrates probabilistic models used pipe. functions diﬀerent arities number children node probabilistic model equal maximum arity function node selected population. function smaller arity ﬁrst children interpreted arguments function challenging solvable class problems. types decomposable problems ﬁxed-length string common onemax concatenated traps. onemax contribution independent context. hand concatenated traps bits trap partition interact cannot eﬀectively processed without considering bits trap partition. order easy recombination-based however since standard variation operators consider interactions diﬀerent program components trap expected lead exponential scalability standard pipe. problems described next. problem order primitive l-primitive order problem consist binary function join complimentary terminals candidate solution order problem binary tree join internal nodes either xi’s leaves. candidate solution’s output determined parsing program tree inorder program expresses inorder parse encountered complement neither complement encountered earlier. unexpressed expressed instead. terminal thus expressed pair example consider candidate solution -primitive order problem shown figure sequence leaves visited inorder parse expression sequence ﬁtness solution thus probabilities diﬀerent functions terminals node probabilistic model. nodes probabilistic model thus consist tables probabilities probability function terminal node. sampling probabilistic model sampling probabilistic model starts root probabilistic model. recursive procedure used generate node. first function terminal generated current node based distribution encoded table probabilities node. function requires several arguments necessary number children generated recursively. recursive generation terminates node whenever terminal generated node thus children generated. since probabilistic model built actual population programs sampling never cross boundaries model. using probabilistic model pipe model sample candidate programs resembles univariate marginal distribution algorithm models string position independently values positions. interactions node context ignored. expected using model lead inferior results problems program components interact strongly similarly univariate model generally fails string positions interact hand diﬀerent program components mutually independent pipe work great. intuition veriﬁed experiments section test problems order test scalability need class problems size modiﬁed inherent problem diﬃculty grow prohibitively fast. ﬁxed-length string decomposable problems bounded diﬃculty used punishing localized hillclimbing requiring mixing whole building blocks order deception. using adversarially designed functions stiﬀ test— sense stiﬀest test—of algorithm performance. idea algorithm beat adversarially designed test functions solve problems equally hard easier adversary. furthermore building blocks deceptive functions identiﬁed respected selectorecombinative almost always converge local minimum. trap designed test mechanisms fitness computed interactions diﬀerent components program considered optimization mislead away global optimum. similarly standard deceptive functions standard expected fail solving trap scalably indicating need linkage learning programs trap also consist binary function join pairs complementary primitives expression mechanism program trap identical order. diﬀerence ﬁtness evaluation procedure. trap expressed primitives ﬁrst mapped l-bit binary string. string expressed; otherwise string resulting binary string partitioned groups bits trap function applied group important feature additively separable trap functions looking performance subset bits corresponding trap seems better propagate shown interactions diﬀerent components program considered expected scale poorly problem. primitives addition order trap join terminal pairs tested pipe order additional primitives primitive negative join junk unexpressed terminals. purpose additional tests determine pipe respond complex interactions unnecessary program primitives. primitive negative-join join aﬀects descendant terminals expressing primitive negation analogically descendants expressed terminal join ancestors considered terminal negated once. join unnecessary solving order introduce less complex easier global optimum. furthermore join introduces interactions order best value leaf depends ancestors. nonetheless interactions relatively simple many leaves expected contain join path root. diﬃculty trap adjusted modifying values problem becomes diﬃcult value increased decreased. -bit deceptive trap function illustrated figure paper traps junk-code terminals junk-code junk terminals represent unnecessary primitives irrelevant particular problem. biological terms junk terminals correspond junk code dna. expression phase junk terminals simadding junk terminals makes optimization problem diﬃcult additional primitives enlarge search space without simplifying problem. inﬂuence junk terminals tuned changing number unique junk terminals. additionally eﬀects increasing number unnecessary primitives performance pipe studied testing pipe -primitive order increasing number junk terminals binary tournament selection used pipe. probability crossover focus eﬀects recombination mutation used. initial population methods generated using standard half-and-half method. maximum tree depth depth minimum tree store global optimum. population size within minimum population size required solve independent runs used. population size determined using bisection method. runs terminated algorithms global optimum number generations large particular problem. results figure shows scalability pipe order without join junk terminals. problem instances diﬀerent size examined; speciﬁcally ﬁgure shows average number function evaluations successful runs respect problem size results indicate pipe slightly eﬃcient pipe scale low-order polynomial. results agreement behavior observed binary-string simple onemax problem. onemax simple umda optimum low-order polynomial time however umda performs slightly better uses eﬀective recombination type problems. stance positive terminals contains unique junk terminals. pipe seem capable dealing irrelevant terminals achieve performance comparable basic order. last sets experiments similar show performance pipe changes adding irrelevant terminals representation. order terminals used number junk terminals ranging experiments diﬀer bound maximum tree depth. figure shows results depth limited figure shows results depth limited problem smaller maximum depth diﬃcult pipe junk terminals obstruct creation optimal solution slightly larger maximum allowed tree. pipe deals better lack space does. however cases number evaluations still appears grow low-order polynomial slower irrelevant terminals added. future work future work study scalability pipe similar approaches problems presented paper problems problem size modiﬁed without aﬀecting inherent problem diﬃculty. eﬀorts introducing linkage learning continue succeed design robust methods provide scalable solution broad classes problems. finally theory designed match achievements area domain trap without join junk terminals. size trap signal diﬀerence problem instances diﬀerent size examined; specifically trap performs slightly better pipe. explained weaker recombination operator recombination causes disruption important partial solutions hypothesized based performance standard similar problems. nonetheless pipe scale poorly indicate exponential growth number function evaluations problem size. figure compares scalability pipe order join. problem instances diﬀerent size examined; speciﬁcally pipe perform similarly basic order without join slight decrease performance interactions introduced join. complementary terminal pairs order solved without considering interactions between diﬀerent program components whereas trap introduces strong interactions make function diﬃcult standard crossover mutation well probabilistic recombination pipe. scalability pipe tested basic order trap. additionally order extended adding either following primitives binary function join junk terminals. thus problem types examined. four problem types scalability pipe ﬁrst tested applying algorithms problem instances diﬀerent size then sensitivity pipe proportion irrelevant terminals relevant ones examined. conclusions results presented paper indicate behavior diﬀerent variants expected similar standard binary-string gas. important consequences fact. first indicated solve classes problems scalably linkage learning incorporated order identify exploit interactions diﬀerent program components. second lessons learned design application binary-string carry argued example ﬁrst steps along direction represented decision-making model population sizing based decision-making population-sizing model standard results also indicate recombination operator captures interactions problem properly increasing mixing eﬀects recombination leads better performance. pipe outperformed standard problems program components could treated independently. fact together need linkage learning encourage application probabilistic recombination operators estimation distribution algorithms domain representatives edas applied domain acknowledgments work partially supported research award research board university missouri. experiments done using hboa software developed martin pelikan david goldberg university illinois urbana-champaign. work also sponsored force oﬃce scientiﬁc research force materiel command usaf grant f--- national science foundation grant dmr- grant dmr- dept. energy grant defg-er u.s. government authorized reproduce distribute reprints government purposes notwithstanding copyright notation thereon. references baluja. population-based incremental learning method integrating genetic search based function optimization competitive learning. tech. rep. cmu-cs-- carnegie mellon university pittsburgh facilitating hierarchical program evolution skip nodes. technical report idsia-- instituto dalle molle studi sull’ intelligenza artiﬁciale lugano switzerland sastry u.-m. o’reilly goldberg. convergence-time models simple genetic algorithm ﬁnite population. illigal report university illinois urbana-champaign illinois genetic algorithms laboratory urbana good stuﬀ why? contextual semantics inﬂuence program structure simple genetic programming. proceedings first european workshop genetic programming apr. miller. gambler’s ruin problem genetic algorithms sizing populations. proceedings international conference evolutionary computation pages also illigal report complexity genetic algorithms exponentially scaled problems. proceedings genetic evolutionary computation conference pages also illigal report", "year": 2005}