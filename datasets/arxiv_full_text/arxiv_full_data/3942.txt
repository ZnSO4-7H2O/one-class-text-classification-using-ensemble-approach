{"title": "Evolutionary Optimization in an Algorithmic Setting", "tag": ["cs.NE", "cs.AI"], "abstract": "Evolutionary processes proved very useful for solving optimization problems. In this work, we build a formalization of the notion of cooperation and competition of multiple systems working toward a common optimization goal of the population using evolutionary computation techniques. It is justified that evolutionary algorithms are more expressive than conventional recursive algorithms. Three subclasses of evolutionary algorithms are proposed here: bounded finite, unbounded finite and infinite types. Some results on completeness, optimality and search decidability for the above classes are presented. A natural extension of Evolutionary Turing Machine model developed in this paper allows one to mathematically represent and study properties of cooperation and competition in a population of optimized species.", "text": "mark burgin eugene eberbach dept. mathematics comp. inf. science dept. univ. california univ. massachusetts hilgard avenue westport road angeles north dartmouth evolutionary processes proved useful solving optimization problems. work build formalization notion cooperation competition multiple systems working toward common optimization goal population using evolutionary computation techniques. justified evolutionary algorithms expressive conventional recursive algorithms. three subclasses evolutionary algorithms proposed here bounded finite unbounded finite types. results completeness optimality search decidability classes presented. natural extension evolutionary turing machine model developed paper allows mathematically represent study properties cooperation competition population optimized species. keywords combinatorial optimization evolutionary computation complexity theory computer science global optimization search theory cost benefit analysis ombinatorial optimization aimed finding optimal solutions complex search problems. categorized exact heuristic methods. exact methods consist branch bound dynamic programming lagrangian relaxation linear integer programming. heuristic methods contain evolutionary algorithms tabu search colony optimization particle swarm optimization simulated annealing. paper argue classification methods combinatorial optimization exact heuristic classes little superficial. everything depends complexity search problem. called exact methods interrupted produce approximate solutions large search problems. example appreciated somebody tries dynamic programming solve npcomplete problems. namely possible exact dynamic programming cities traveling salesman problem inexact dynamic programming solutions hundreds thousands cities tractable. although inexact evolutionary algorithms simulated annealing methods guarantee find exact solutions traveling salesman problem general case guaranteed infinite number generations. however solving problem infinite number steps goes beyond classical algorithms turing machines spite common mathematics encounters steady resistance algorithmic-based conventional computer science. paper show achieve results i.e. find exact solutions hard problem finite time namely super-recursive algorithms allow solve many problems undecidable realm recursive algorithms argue beneficial computer science beyond recursive algorithms making possible look exact solutions intractable problems even find solutions undecidable problems whereas recursive solutions exist. basic computational model take evolutionary turing machines introduced extend computational power allowing turing machines also inductive turing machines limit turing machines powerful turing machines. paper organized follows. section give short primer problem solving. section introduces inductive limit turing machines substantially expressive extensions turing machine model. section presents evolutionary algorithms evolutionary turing machine formal model evolutionary computation. section three subclasses evolutionary computation defined bounded finite unbounded finite infinite. results completeness optimization convergence decidability three subclasses obtained section formal model cooperating competitive population agents trying achieve common goal developed section section contains conclusions problems solved future. algorithm provides recipe solve given problem. simplicity assume algorithm consists finite number rules easily comprehensible well defined implementable meaning. addition consider algorithms states like turing machines finite automata. recursive algorithm starts initial state terminates terminal state terminal/goal states. algorithm reaches goal state algorithm satisfied goal problem solved. goal test determines whether given state goal state. states reachable initial state forms search space algorithm. however guaranty solution problem belongs space even space states. thus solution problem interpreted search process states. state space forms directed graph nodes states arcs nodes actions. search deterministic nondeterministic/probabilistic. multiple solutions ranked using objective function particular none several optimal solutions problem. using objective functions allows capturing process iterative approximation solutions different qualities solutions contrast simply binary decision goal reached not. cases impossible reach goal need approximations beginning. consider optimization problem spaces optimizing optimization space. optimization space elements representations objects optimized. instance elements optimization space fixed binary strings genetic algorithms finite state machines evolutionary programming parse trees genetic programming vector real numbers evolution strategies usually assumed optimization space contains representations form possible optimized elements given kind. practice finite part space considered. however able treat optimization problem mathematical tools need rule take infinite space instance step classical optimization schema finite number species representations involved. species form optimization pool corresponding generation. optimizing space elements optimization algorithms. also relations elements thus kind algorithm space. instance turing machines binary relation machine computing power machine algorithm space. genetic algorithms form optimizing space. optimization space contains solution subspace elements solutions problem optimizing space contains solving subspace algorithms give solutions problem without losing generality sufficient consider minimization problems. however traditionally many problems treated maximization problems. objective function expanded multiple objective funtions problem considered several objectives. aggregating function arbitrary requirement becomes identity function obtain pareto optimality min{ using pareto optimality simpler however lose explicit dependence several objectives objective functions allow capturing convergence convergence rate construction solutions much better symbolic goals. obviously every symbolic goal/termination condition expressed objective function. example simple objective function following goal satisfied objective reach goal maximization problem. typically much complex objective functions used better express evolutions solutions. keep independent representation allow compare different solving algorithms distance function absolute value difference objective functions extend definition distance pairs points distance point points inf{|f solution convergence corresponds topological convergence discrete spaces. asymptotical solution convergence corresponds topological convergence metric spaces solution convergence error corresponds fuzzy convergence metric spaces case differentiable functions solution convergence rate derivative distance function conventional derivative fuzzy derivative sense contrast conventional differentiation fuzzy differentiation developed neoclassical analysis allows differentiate discontinuous even discrete functions. convergence rate describes one-step performance algorithm positive convergence rate means algorithm drifts towards optimum negative rate signifies drift away optimum. positive convergence rate search algorithm typically converge asymptotically converge optimum. best search algorithms typically high convergence rate small number steps reach optimum. similar optimal search optimal convergence convergence rate defined. search algorithm probabilistic multiple agents algorithms like kÏ‰-optimization n-player games coevolutionary algorithms collective intelligence multiple agents search cooperative competitive independent. cooperative search agents results others find optimum; competitive search agents compete resources search optimum independent search agents interact. case optimization space consists algorithms classes search algorithms online offline. online algorithms action execution computation interleaved offline algorithms complete solution optimization problem computed first executed without perception. give short description inductive turing machines detailed exposition given structure inductive turing machine abstract automaton consists three components called hardware software infware. infware description specification information processed inductive turing machine. computer infware consists data processed computer. inductive turing machines abstract automata working symbolic information form words conventional turing machines. consequently formal languages inductive turing machines works constitute infware. computer hardware consists devices constitute computer. similar inductive turing machine three abstract devices control device finite automaton controls performance processor operating device corresponds several heads conventional turing machine; memory corresponds tape tapes conventional turing machine. memory simplest inductive turing machine consists three linear tapes operating device consists three heads head turing machine works corresponding tapes. memory divided different rule uniform cells. structured system relations organize memory well-structured system provide connections ties cells. particular input registers working memory output registers separated. connections cells form additional general case cells different types. different types cells used storing different kinds data. example binary cells type store bits information represented symbols byte cells store information represented strings eight binary digits. symbol cells store symbols alphabet machine cells conventional turing machines type. natural number cells type used random access machines cells memory quantum computers store q-bits quantum bits cells tape real-number turing machines type store real numbers. different kinds devices combined device several types memory cells. addition different types cells facilitate modeling brain neuron structure inductive turing machines. possible realize arbitrary structured memory inductive turing machine using linear one-sided tape this cells enumerated natural order first infinity. decomposed three parts according input output registers working memory this nonlinear connections cells installed. inductive turing machine memory works head/processor moving right left cell given cell uses installed nonlinear connections. realization structured memory allows consider inductive turing machine structured memory inductive turing machine conventional tapes additional connections established. approach many advantages. inductive turing machines structured memory treated multitape automata additional structure tapes. conceivable study different ways construct structure. addition representation memory allows consider configuration structured memory word written unstructured tape. computers operational device performs simple operations. consists unit change symbol cell observed cell another using connection exactly head turing machine does. possible processor consists several processing units similar heads multihead turing machine. allows model natural various real abstract computing systems inductive turing machines. examples systems multiprocessor computers; turing machines several tapes; networks grids clusters computers; cellular automata; neural networks; systolic arrays. know programs constitute computer software tell system software inductive turing machine also program form simple rules rule directs step computation inductive turing machine rule means state control device processor observes cell symbol state becomes processor writes symbol cell situated. rule means processor moves next cell connection type rule combination rules like turing machines inductive turing machines deterministic nondeterministic. deterministic inductive turing machine connection type cell. nondeterministic inductive turing machine several connections type cells connecting cells. connection prescribed instruction type goes cell observed stays cell. connections cell itself. also stays cell. possible observes empty cell. represent situation symbol thus possible elements and/or rules equal rules types. rules describe situations observes empty cell and/or simply erases symbol cell writing nothing rules type allow inductive turing machine rewrite symbol cell make move step. rules separate operations. rules inductive turing machine define transition function describe changes consequently also determine transition functions control device chooses system rules rule left part equal qhai performs operation prescribed rule. rule left part machine stops functioning. several rules left part works nondeterministic turing machine performing possible operations. comes final states machine also stops functioning. cases continues operation without stopping. abstract automaton well computer three things important receives data process data obtains results. contrast turing machines inductive turing machines obtain results even case operation terminated. results essential increase performance abilities systems algorithms. computational result inductive turing machine word written output register halts control device final state never stops step computation content output register becomes fixed change although machine continues function. cases gives result. limit turing machines structure inductive turing machines. difference general obtaining result computation. obtain result limit turing machines need topology words processed machines. limit turing machine works words alphabet words topology defined. machine works produces output tape words result computation limit turing machine limit sequence words topology evolutionary algorithm probabilistic beam hill climbing search algorithm directed fitness objective function. beam maintains multiple search points hill climbing means current search point search tree remembered termination condition often optimum fitness function. population representation consisting individuals finite state machines evolutionary programming parse trees genetic programming vector reals evolution strategies selection operator variation operator initial population final populations satisfying termination condition desirable termination condition optimum fitness function extended fitness function best individual population defined typically domain nonnegative real numbers. many cases impossible achieve verify optimum. thus another stopping criterion used definition applicable typical including possible describe emerging subareas like colony optimization particle swarm optimization. co-evolutionary algorithms typically multiple populations e.g. vectors representation vectors evolved. fact restriction type representation used. sometimes order variation selection reversed i.e. selection applied first variation second. variation selection depend fitness function. course possible think implement complex variants evolutionary algorithms. evolutionary algorithms evolve population solutions subject self-adaptation well. extension used evolution strategies technically means domain variation operator selection operator fitness function extended operate population representation well encoding evolutionary algorithm. next part paper discuss general evolving parallel population well evolutionary algorithm sure evolution nature static rate readers would argue applications currently static evolutionary algorithms approach still valid assuming utilized evolutionary algorithm fixed. advantage non-static evolutionary algorithms allow capturing complexity adaptation search process. formally evolutionary algorithm looking optimum fitness function violates classical requirements recursive algorithms. termination condition optimum fitness function terminate finite number steps. algorithmic approach artificial stop criterion added evolutionary algorithm remain recursive stopped finite number generations visible progress observable. naturally general case evolutionary algorithms instances super-recursive algorithms. generation given advance generation depends predecessor only i.e. outcome generation population obtained applying recursive variation selection operators working population remark variation selection operators recursive allow problem computation turing machines. later release restriction allow nonrecursive solutions. remark general fitness function subject evolution well evolution potentially infinite process. changing transition function thought kind evolvable hardware assuming fixed hardware think reprogrammable evolutionary algorithms. model variation selection operators realized turing machines. natural turing machine computes values fitness function brings concept weighted turing machine. another example weighted turing machines particular weighted algorithms general turing machines compute recursive real numbers recursive real-valued functions necessary remark cases easy compute values fitness function examples situations fitness functions length program number parts simple system. however many cases computation values fitness function based complex algorithm demand many operations. instance optimized species programs fitness function time necessary achieve program goal computation values fitness function demand functioning simulation programs generated evolutionary process. encounter similar situations optimized species computer chips parts plane cars. case computation values fitness function involves simulation. weighted computation realized weighted turing machines allows extend formal algorithmic model evolutionary computation defining weighted evolutionary turing machine. generation given advance generation depends predecessor only i.e. outcome generation population obtained applying recursive variation selection operators working population computing fitness function goal state wetm represented population satisfying termination condition. desirable termination condition optimum fitness performance measure best individual population termination condition satisfied wetm halts otherwise input population generated concept universal automaton/algorithm plays important role computing useful different purposes. general form concept developed definition automaton/algorithm universal class given description automaton/algorithm input data gives result input gives result gives result input leads immediately following turing's ideas concept universal turing machine extensions universal evolutionary turing machine weighted evolutionary turing machine. define universal evolutionary turing machine abstraction possible etms similar universal turing machine defined abstraction possible turing machines. optimizing space optimization space codification automata/algorithms evolutionary algorithms series algorithms instance evolutionary turing machine series turing machines. definition universal evolutionary turing machine optimization space given pair start population machine takes pair input produces population turing machine working population takes pair input produces population turing machine working population general takes pair input produces population turing machine working population generation given advance generation depends predecessor only i.e. outcome generation pair applying recursive variation selection operators operating population evolutionary algorithm well goal state uetm represented pair satisfying termination condition. desirable termination condition optimum fitness performance measure f)f)) best individual population solutions evolutionary algorithms aggregating function evolutionary algorithm fitness function problem-specific fitness function. termination condition satisfied uetm halts otherwise pair input/population generated. note infinite sequence turing machines generally work like limit turing machine. limit turing machine expressive definition universal weighted evolutionary turing machine wetm optimization space given pair wetm start population machine takes pair input produces population weighted turing machine working population takes pair input produces population weighted turing machine working population general takes pair input produces population weighted turing machine working population definition gives properties imply existence. theorem class weighted evolutionary turing machines given recursively computable weight function universal weighted evolutionary turing machine. know hardware allows computer realize/use different modes computation. similar algorithmic structure provides different types evolutionary computations. example evolutionary algorithms termination condition fixed maximum number generations belong class general evolutionary algorithms improve solutions guarantee find global optimum fitness function. example class represented evolutionary algorithms unknown complex fitness function global optimum unable verify next generation invoked. thus theory computation last forever however global optimum found received finite number steps example class represented evolutionary algorithms elitism completeness looking optimum fitness function. many cases last generation contain optimal solution. example class represented evolutionary algorithms termination condition fixed unbounded number generations. another system belongs class evolutionary algorithms termination condition lack improvement fitness function process potentially unbounded. example class represented evolutionary algorithms complex unknown fitness function number generations fixed unbounded. again optimum reached guarantee maintained however process search fixed potentially infinite. example class represented evolutionary algorithms elitism completeness looking optimum fitness function unbounded fixed number generations. limit guarantee contain optimal solution example evolutionary algorithms elitism completeness looking best evolutionary algorithm belong class know best evolutionary algorithm exist i.e. limit solution outside domain evolutionary algorithms. however outside domain limit approximated infinite sequence better evolutionary algorithms process never stops require infinite number turing machines. definition evolutionary computation search optimal uetm termination condition optimum problem-specific fitness function convergent optimal solutions definition evolutionary computation search optimal uetm termination condition optimum search fitness function together problem-specific termination condition allowing find solution convergent optimal solutions complete termination condition fixed number generations incomplete optimum fitness function; guaranteed optimal termination condition optimum fitness function complete termination condition fixed number generations incomplete optimum fitness function; optimal termination condition optimum fitness function complete elitism selection used; coevolutionary systems e.g. evolution process takes place usually different populations interact other. coevolutionary systems special case concurrent systems fitness function population depend state evolution processes multiagent/coevolutionary technique developed kennedy russell eberhart population particles \"flies\" problem space. inspired bird flocking fish schooling buffalo herds swarming theory social behaviors. bird flock becomes swarm steering toward center matching neighbors' velocity avoiding collisions. operates population individuals variation applied without selection. individual position velocity updated according relationship individual's parameters best location individual population found far. search biased toward better regions space result sort \"flocking\" toward best solutions. particle swarm optimization population always consists species changing characteristics species example positions search space. model changes computed etm. allows optimizing system linear shifts particles search best position also efficient recursive transformations particles movements. colony optimization another multiagent technique developed marco dorigo coauthors low-level interactions artificial ants result complex behavior larger colony. social insects ants bees termites wasps viewed powerful problem-solving systems sophisticated collective intelligence. composed simple interacting agents intelligence lies networks interactions among individuals individuals environment. social insects find food divide labor among nestmates build nests respond external challenges. algorithms inspired colonies real ants deposit chemical substance ground. substance influences behavior individual ants. greater amount pheromone particular path larger probability select path. artificial ants algorithms behave similarly. abstract pheromone parameter fulfills similar function like position/velocity simulated annealing temperature. forms communication/ interaction channel ants. coevolution colony optimization particle swarm optimization seem potentially useful subareas evolutionary computation expressing interaction multiple agents however paradoxically current applications techniques used obtain optimal solutions optimization single agent behavior optimization group agents trying achieve common goal primarily fitness function optimized single individual population population whole. definition parallel evolutionary turing machine tmi; ...; consists collection series turing machines working population generations transition function turing machine represents evolutionary algorithm works whole generation based fitness performance measure evolved generations zero generation given advance generation depends predecessor only i.e. outcome generation subgeneration obtained applying recursive variation selection operators working whole generation realized turing machine goal state petm represented population satisfying termination condition. desirable termination condition optimum unified fitness performance measure whole population termination condition satisfied petm halts otherwise input population generated machines tmi. similar define parallel weighted evolutionary turing machine. definition parallel weighted evolutionary turing machine tmi; ...; consists collection series turing machines working population generations transition function turing machine represents evolutionary algorithm works whole generation based fitness performance measure evolved generations zero generation given advance generation depends predecessor only i.e. outcome generation subgeneration obtained applying recursive variation selection operators working whole generation computing fitness function realized turing machine goal state petm represented population satisfying termination condition. desirable termination condition optimum unified fitness performance measure whole population models already prepared handle situation. enough assume fitness functions computed whole population separate individuals population only. assume population i.e. consists individuals subpopulations. simplicity consider individuals f)f)) {mâ€¦mp} x={xâ€¦xp}. define problem-specific fitness function whole population f)â€¦fp)) aggregating function fitness function j-th individual evolutionary population f)=f)â€¦fp)) aggregating function fâ€¦fp fitness function j-th evolutionary algorithm evolutionary algorithm responsible evolution definition j-th individual cooperates time whole population problem specific fitness function otherâ€™s individuals fitness functions fixed i.e. words individual improves fitness function whole population cooperates fitness function whole population population exhibits cooperation whole individual cooperates moments time always cooperative otherwise sometimes cooperate sometimes compete note cooperation replaces elitism sufficient condition convergence cooperating members population looking optimum fitness whole population separate individual. surprise whole paper presented formal model cooperation competition evolutionary computation. believe model constitutes first formal much precise generic approach trying capture essence cooperation competition evolutionary algorithms. possible precise formulation notions cooperation competition completeness various types optimization extension notion decidability used context several extensions evolutionary turing machine models. justified paper evolutionary algorithms form special case superrecursive algorithms powerful conventional recursive algorithms. similar evolutionary turing machines expressive conventional turing machines belong family superrecursive models computation proposed several types evolutionary computation including bounded finite class unbounded finite class powerful infinite evolutionary computation class. types presented basic results completeness optimality search optimality total optimality decidability. extended model parallel weighted evolutionary turing machines capture properly optimization population trying achieve common goal. demonstrated extension simple natural model allows capture cooperation competition whole population. surprising result obtained cooperation fulfills similar function elitism maintain optimum speeds convergence rate case cooperating agents. course much research needed. seems possible desirable generalize results beyond evolutionary computation search. example kÏ‰optimization meta-search algorithm -calculus process algebra model allows simulate many search algorithms could used generalize results. left future research.", "year": 2006}