{"title": "Sequential Relevance Maximization with Binary Feedback", "tag": ["cs.LG", "cs.AI"], "abstract": "Motivated by online settings where users can provide explicit feedback about the relevance of products that are sequentially presented to them, we look at the recommendation process as a problem of dynamically optimizing this relevance feedback. Such an algorithm optimizes the fine tradeoff between presenting the products that are most likely to be relevant, and learning the preferences of the user so that more relevant recommendations can be made in the future.  We assume a standard predictive model inspired by collaborative filtering, in which a user is sampled from a distribution over a set of possible types. For every product category, each type has an associated relevance feedback that is assumed to be binary: the category is either relevant or irrelevant. Assuming that the user stays for each additional recommendation opportunity with probability $\\beta$ independent of the past, the problem is to find a policy that maximizes the expected number of recommendations that are deemed relevant in a session.  We analyze this problem and prove key structural properties of the optimal policy. Based on these properties, we first present an algorithm that strikes a balance between recursion and dynamic programming to compute this policy. We further propose and analyze two heuristic policies: a `farsighted' greedy policy that attains at least $1-\\beta$ factor of the optimal payoff, and a naive greedy policy that attains at least $\\frac{1-\\beta}{1+\\beta}$ factor of the optimal payoff in the worst case. Extensive simulations show that these heuristics are very close to optimal in practice.", "text": "motivated online settings users provide explicit feedback relevance products sequentially presented them look recommendation process problem dynamically optimizing relevance feedback. algorithm optimizes tradeoff presenting products likely relevant learning preferences user relevant recommendations made future. assume standard predictive model inspired collaborative ﬁltering user sampled distribution possible types. every product category type associated relevance feedback assumed binary category either relevant irrelevant. assuming user stays additional recommendation opportunity probability independent past problem policy maximizes expected number recommendations deemed relevant session. analyze problem prove structural properties optimal policy. based properties ﬁrst present algorithm strikes balance recursion dynamic programming compute policy. propose analyze heuristic policies ‘farsighted’ greedy policy attains least factor optimal payoff naive greedy policy attains least factor optimal payoff worst case. extensive simulations show heuristics close optimal practice. predicting preferences users order present relevant engagements fundamental component recommendation system years wide variety approaches proposed problem survey). include content based approaches rely generating user item proﬁles based available data collaborative ﬁltering approaches recommend items based similarity measures users and/or items combination paper motivated several settings interest explicit feedback relevance recommendations received user small timescales pursue less studied approach modeling recommendation process sequential optimization problem. examples settings. online retail user enters online shopping portal purchase accessory e.g. watch. sequentially presented various design choices based feedback designs system adaptively presents recommendations likely liked her. advertising online video video inherently disruptive user’s attention thus potentially valuable sponsored search strong motivation designing allocation mechanisms take account relevance users. services like youtube hulu collect explicit feedback relevance shown feedback used adaptively learn preferences users show relevant ads. consider model derived cluster models collaborative ﬁltering history user behaviors compressed predictive model users classiﬁed ‘types’ capture preference proﬁle user. typical recommendation generation algorithm dynamically observes user behavior uses maximum-likelihood estimates based predictive model choose products likely relevant. approach replaces maximum-likelihood estimation sophisticated optimization problem conﬂicting goals presenting relevant products based current predictions user preferences learning underlying type user relevant engagements shown later concurrently optimized precise systematic way. model assumes user enters system sampled probability distribution types priori known system designer. type associated string ‘relevance’ ratings different categories products. focus simplest case relevance rating binary i.e. user considers category products either relevant irrelevant. assume number recommendation opportunities available session random modeled geometric random variable arising assumption user stays additional opportunity ﬁxed probability independent past. setting focus problem adaptively maximizing expected cumulative relevance recommendations presented user session. main contribution paper analysis sequential relevance maximization problem. ﬁrst glance optimal policy determined using naive recursive algorithm. typical algorithms highly inefﬁcient repetition redundant work. standard tool solve problems dynamic programming turns inefﬁcient recursive algorithms efﬁcient iterative solutions. unfortunately case state space program grows exponentially number types categories. further efﬁcient enumeration states difﬁcult. ﬁrst derive certain properties structure optimal policy using probabilistic interchange arguments. using properties provide algorithm strikes balance recursion dynamic programming solve optimal policy. unfortunately algorithm still remains computationally prohibitive. motivated structural results propose analyze heuristic policies ‘farsighted’ greedy policy easier compute naive greedy policy analogous maximum-likelihood prediction performed typical recommendation systems. prove policies approximately optimal i.e. achieve constant factor optimal payoff. ﬁnally perform extensive simulations random problem instances observe heuristic policies typically perform much better predicted worst case bounds. idea posing recommendation process optimization problem new. best knowledge earliest appearance literature traced back proposed decision-theoretic modeling problem generating recommendations user navigating airport. proposed framework modeling sequential optimization problem online recommendation systems markov decision process underlying formulation quite general focus deﬁning establishing paradigm. model consider hand structured focus analysis resulting optimization problem. sequential relevance maximization problem closely related bayesian multi-armed bandit problems. multi-armed bandit problem ﬁrst introduced thompson decision-maker faces arms whose reward characteristics uncertain seeks optimize sequence pulled maximize long-run reward. problems faces tradeoff exploration i.e. learning reward characteristics arms exploitation i.e. accumulating rewards choosing good arms based current estimates. problems commonly studied distinct settings bayesian stochastic different analytical approaches used each. model falls bayesian setting initial prior distribution assumed parameters probabilistic reward generating model performs bayesian updates estimates rewards observed. solves well-deﬁned problem maximizing either long-term average discounted cost. standard solution tool case dynamic programming. stochastic setting recent survey) assume prior distribution parameters instead tries policies minimize worst case rate losses relative expected reward best accumulated focus characterizing optimal rate. literature settings focused case rewards different arms statistically independent. bayesian case seminal result gittins shows optimal policy dynamically computes index independently arms picks highest index step. case relevance different products correlated hidden user type hence type bayesian problem correlated dependent arms. well known decomposition result gittins hold case. years sporadic progress tackling problem papers focusing speciﬁc models. analyze two-armed bandit problems reward characteristics arms known corresponds reward distribution known leads natural dependence arms. case studies another version general case arms still remains open. problem arms grouped clusters dependent arms case gittins decomposition result partially extended. recently considered speciﬁc model problem dependent arms analyzed performance greedy policy derived asymptotic optimality results. type problems recently also gained attention stochastic setting case binary rewards) although formulations techniques setting different. broad conclusion body work correlation arms exploited achieve better regret rates. another important difference problems problem that since product presented since ﬁnite number products category bound number times ‘arm’ pulled. thus cannot ‘exploit’ forever forced experiment intermittently. special case category single product problem also related active sequential hypothesis testing problem problem seeks speedily learn hidden random variable adaptively choosing sequence correlates observe cost observation. formulation would appropriate objective quickly learn user type without concern relevance feedback. since goal optimize latter different approach necessary. structure paper follows. section introduce model deﬁne relevance optimization problem. section devoted analysis problem derive structural properties optimal policy ﬁnally present algorithm compute section propose policies easier compute prove approximately optimal. section extensively simulate approximately optimal policies randomly generated problem instances compare performance optimal policy. finally section summarizes work discusses extensions model. proofs results found appendix. consider setting user enters online system sequentially presented products different categories goal maximizing number relevant products presented eventually leaves system. assume total products. products divided categories category representing similar products. categories labeled {··· category products. given user considers categories relevant known priori. system designer elicits explicit feedback relevance product presented. feedback obtained answer explicit question assumed binary takes value product relevant assume feedback accurately provided user. product cannot presented user session. hence maximum number products shown restricted capture uncertainty preferences user assuming user possible types actual type user latent random variable observed beginning session. denote random variable. corresponding probability distribution. assume system designer knows distribution denote ﬁxed binary relevance user type product category feedback user type category. type user known category introduce random variable represents binary feedback user product category. induces probability distribution convenient associate user type h-length binary vector values different categories. hence deﬁne relevance matrix whose rows represent user types columns represent product categories. figure example relevance matrix four types users labeled four product categories labeled category speciﬁed number products. instance type ﬁnds category relevant ﬁnds irrelevant. number display opportunities available user leaves system modeled random variable ···} geometric probability distribution notice type space quite general. user joint distribution ﬁnding different categories relevant think user convex combination types corresponding realizations binary relevance vectors associated probabilities. also variation observed feedback received products belong category products declared individual categories. although increases problem size analysis remains applicable. words user dynamics system modeled memoryless random process user stays additional opportunity probability exits probability independently past. assumes least opportunity always available. finally random variable independent user type feedback product obtained every display opportunity since feedback product every product category assume feedback requested obtained product presented belongs category shown before. primary objective system designer maximize expected number relevant products presented user session. user enters website display opportunity system designer adaptively decides product shown user taking user feedback obtained past consideration. deﬁne objective formally. policy designer sequence maps {ψ··· mapping possible observations user feedback time denoted possible actions choices products. feasible policies. objective designer policy maximizes expected number relevant shown session constraint product shown once. denote product chosen time policy chosen well deﬁned random variable. abuse notation category. objective publisher following. mentioned earlier problem type bayesian multi-armed bandit problem correlated rewards additional constraint number times pulled. ﬁrst look solve problem using following recursive program algorithm well known recursive algorithms inefﬁcient. usual problem recursion leads repeating work. happens overlapping subproblems unfortunately case here. turning inefﬁcient recursive algorithms efﬁcient iterative algorithms role dynamic programming. requires deﬁne state space possible ‘information states’ opportunity encapsulate information gained till time case information state corresponds smaller relevance matrix obtained computing posterior distribution types eliminating rows corresponding user types conditional probability columns corresponding categories exhausted. state space thus grows prohibitively large time enumeration cumbersome. next section prove structural properties optimal policy based provide efﬁcient algorithm strikes balance recursion iteration order compute policy. structural results motivated following examples. example triangular relevance matrix consider relevance matrix shown figure quick circumspection convinces optimal policy shows categories order positive feedback obtained category advertisers category exhausted. this observe policy attains optimal payoff obtained case type user known arrival. structurally partial order relation categories category ‘dominates’ types relevant strict subset types ﬁnds relevant. example shows partial order relation leads complete ordering categories optimal policy simply presents categories according order. case? lemma prove empty return category denote user types relevant also matrix obtained removing column corresponding category rows corresponding user types matrix obtained removing column corresponding category rows corresponding user types finally denote distribution user types conditional event distribution user types conditional appropriate generalization property arbitrary relevance matrices using probabilistic interchange argument. show category dominates optimal policy presented other. example permutation relevance matrix consider relevance matrix shown figure argue case optimal policy greedy choose category maximum expected number relevant ads. fact relevance matrix permutation smaller block matrices multiple categories each consider relevance optimization problem smaller blocks separately greedily choose order blocks chosen. ﬁrst present following intuitive property. lemma optimal allocation policy opportunity conditional past observations exists product category generate positive feedback probability i.e. product shown allotted immediately. multiple products allotted order. property implies positive feedback received product belonging particular category products category scheduled presented immediately following opportunities. proof uses simple probabilistic interchange argument. describe next property ﬁrst formally deﬁne ideas. dynamic allocation products opportunities call opportunity experimentation opportunity conditional information obtained time single category probability existed category previous lemma tells exhaust advertisers category. since category experimentation opportunity brings non-trivial problem deciding category present user next. thus non-trivial decisions optimal dynamic allocation policy taken experimentation opportunities. user types non-zero probability conditional history. note observing feedback allocation made experimentation opportunity categories available i.e. presented till opportunity relevance matrix rows corresponding types columns corresponding categories finally category user types category relevant. deﬁnition category dominates category opportunity categories dominated category called non-dominated categories. instance figure non-dominated categories since dominates show following. lemma optimal allocation policy experimentation opportunity product presented must non-dominated category. words lemma says user types category relevant contained user types category relevant optimal policy category presented category proof lemma also uses probabilistic interchange argument. observe claim lemma intuitively obvious fact. argue cases presenting category dominated help learn true user type faster thus perform better allocation future opportunities. indeed goal minimize expected number opportunities taken learn user type exactly property clearly hold generic class non-dominated categories satisfy condition means class categories found relevant exactly types. called non-dominated equivalence class categories denotes types class relevant. allow class singleton deﬁnition suppose non-dominated equivalence classes {u··· partition non-dominated categories relevance matrix. non-dominated equivalence classes categories denoted furthermore sets types {mu··· muk} mutually disjoint non-dominated equivalence classes partition type space. case relevance matrix represented block diagonal matrix composed smaller block matrices blocks) block matrix corresponding equivalent non-dominated class. small block composed columns category class columns corresponding categories class dominates. products presented recompute relevance matrix feedback lose non-dominated categories categories become non-dominated. thus nondominated equivalence classes change. case categories added class non-dominated categories want able identify class class. done since categories equivalence class relevance matrix ﬁrst display opportunity continue remain class long non-dominated presented. thus class subsequent display opportunities identiﬁed equivalence categories ﬁrst display opportunity. example relevance matrix figure mentioned non-dominated categories ﬁrst opportunity. suppose presented negative feedback received. relevance matrix obtained deleting rows corresponding type type column corresponding category remaining non-dominated class case identify class contained ﬁrst opportunity. similarly present initially negative feedback {cd} left non-dominated equivalence class result merging classes {d}. case class identiﬁed original classes brings following property relevance matrix easily veriﬁed. lemma consider relevance matrix initial non-dominated classes categories suppose category class presented. suppose negative feedback received category consider relevance matrix obtained deleting rows corresponding user types presented category relevant column corresponding presented category. non-dominated equivalence classes categories satisﬁes intuitively because negative feedback obtained opportunity rows corresponding user types provide positive feedback shown category deleted thus cannot happen category dominated opportunity becomes non-dominated hand positive feedback completely non-dominated equivalence classes appear relevance matrix computed posterior update. example presented positive feedback received relevance matrix positive probability types case dominated hence non-dominated equivalence classes notice appears class. lemmas reveal following structure optimal policy. beginning non-dominated equivalence classes categories classes presented certain order long keep getting negative feedback. class obtains positive feedback process present products class ‘zoom next level restart non-dominated equivalence classes. utilizing structure following algorithm computes optimal payoff. thus user types classes labels irrelevant class relevant. relevance matrix obtained deleting rows corresponding user types columns corresponding categories classes categories finally probability distribution user types conditional event deﬁne optimization problem deﬁned domain possible orderings nondominated equivalence classes categories problem solved efﬁciently using dynamic programming opposed comparing possible orderings. deﬁne state program step classes k··· presented till step substantial reduction state space comes fact depend order classes presented hence state program state step worst case number sub-programs need called evaluate payoff-to-go corresponding classes presented i.e. thus level recursive program number sub-programs called exponential number non-dominated equivalence classes level worst case. considering this turn good heuristic policies easier compute. policy assumes payoff-to-go ‘next level’ onwards given. since recursively compute approximation payoff-to-go assuming follow greedy strategy subsequent levels optimization problem. algorithm computes proposed policy payoff. note computational savings compared algorithm computing optimal policy. comparison equation classes presented already possibilities worst case. thus number times sub-program called +++···+ thus level recursive program number sub-programs called quadratic number equivalence classes level. prove following performance guarantee policy. theorem lmin minj∈··· minimum number products category total number categories. farsighted greedy algorithm achieves +β−βh−βlmin factor optimal payoff. note worst case large lmin case adaptive greedy policy achieves factor optimal payoff. idea proof follows. departure optimality level sources fact payoff-to-go next level onwards approximation optimal payoff-to-go order non-dominated classes presented current level chosen greedily. assumes ratio approximation optimal payoff-to-go optimal payoff-to-go next level quantify departure optimality greedy policy current level compute bound worst case ratio current payoff-to-go optimal current payoff-to-go show operator contraction. thus recursively sequence lower bounds uniformly bounded ﬁxed point sequence quantity theorem. note description algorithm simpliﬁed fully exploiting recursive structure; presented current form show correspondence algorithm also facilitate also obtain lower bound ratio payoffs either heuristic algorithms optimal algorithm values close intuitively follows observation user stays long enough number opportunities available greater policy obtains positive feedback possibly obtain. theorem feasible policy attains factor optimal payoff. section compare performance greedy foresight policy naive greedy policy optimal policy. generate random samples relevance matrices associated randomly chosen priors. compute payoff three policies ranging plot average minimum across samples ratio payoff non-optimal policy optimal policy. results shown figure note policies perform close optimal even worst case across samples. also observe close close payoff policies approach optimal payoff corroborates bounds theorems curve corresponding naive greedy policy smooth policy depend hence resulting payoff continuous main contribution paper introduction analysis sequential relevance maximization problem binary feedback. problem naturally arises several settings designer needs adaptively make sequence suggestions user learning preferences feedback. basic framework amenable extensions adapt approach practical setting assumptions hold. example assume number display opportunities session independent type user relevance feedback hold practice. example user likely leave sooner consecutively shown irrelevant products. also central assumptions user feedback binary practice beneﬁt ﬁne-grained feedback user. example user convey rating product number case would want maximize ratings obtained products shown session. another interesting extension incorporate values products maximizes total value relevant products shown user session. leave extensions future work. user type personalization current personalization services important recommendation system sensitive transience preferences users. example user’s preference music change every depending mood company etc. sequential optimization approach generating recommendations proactively learn changes user preferences freshly eliciting relevance feedback carefully chosen products time user enters system. model considered paper type user captures preferences session consideration prior distribution types assumed known system designer. interpretation distribution captures preferences ‘typical’ user population estimated observed behavior past users. another interpretation aligned notion personalization think distribution capturing variation preferences user multiple sessions. example naive interpretation imagine type captures ‘mood’ person sampled independently everyday preferences music particular depends mood day. even generally could cross-temporal dependencies types. desires optimize performance recommendation process multiple sessions needs also estimate type evolution process. leave considerations future work.", "year": 2015}