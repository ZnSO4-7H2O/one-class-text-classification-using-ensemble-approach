{"title": "Structured Best Arm Identification with Fixed Confidence", "tag": ["cs.LG", "cs.AI"], "abstract": "We study the problem of identifying the best action among a set of possible options when the value of each action is given by a mapping from a number of noisy micro-observables in the so-called fixed confidence setting. Our main motivation is the application to the minimax game search, which has been a major topic of interest in artificial intelligence. In this paper we introduce an abstract setting to clearly describe the essential properties of the problem. While previous work only considered a two-move game tree search problem, our abstract setting can be applied to the general minimax games where the depth can be non-uniform and arbitrary, and transpositions are allowed. We introduce a new algorithm (LUCB-micro) for the abstract setting, and give its lower and upper sample complexity results. Our bounds recover some previous results, which were only available in more limited settings, while they also shed further light on how the structure of minimax problems influence sample complexity.", "text": "study problem identifying best action among possible options value action given mapping number noisy micro-observables so-called ﬁxed conﬁdence setting. main motivation application minimax game search major topic interest artiﬁcial intelligence. paper introduce abstract setting clearly describe essential properties problem. previous work considered two-move game tree search problem abstract setting applied general minimax games depth non-uniform arbitrary transpositions allowed. introduce algorithm abstract setting give lower upper sample complexity results. bounds recover previous results available limited settings also shed light structure minimax problems inﬂuence sample complexity. keywords best identiﬁcation monte-carlo tree search game tree search structured environments multi-armed bandits minimax search motivated problem ﬁnding optimal move minimax tree search noisy leaf evaluations introduce best identiﬁcation problems structured payoﬀs micro-observables. problems learner’s goal best payoﬀ ﬁxed known function unknown values. round learner choose micro-observables make noisy measurement study problems so-called ﬁxed conﬁdence setting. special case problem standard best identiﬁcation seen ﬂurry activity last decade e.g. recently garivier considered motivating problem mentioned above. however considered simplest instance players alternate single round. main observations ruitong huang mohammad ajallooeian csaba szepesvári martin müller. license cc-by https//creativecommons.org/licenses/by/./. attribution requirements provided http//jmlr.org/papers/v./ajallooea.html. two-move problems solved eﬃciently considers problem instance nested best identiﬁcation problem. proposed algorithms ﬁxed conﬁdence setting vanishing conﬁdence setting provided upper bounds. implicit lower bound also brieﬂy sketched together plan derive algorithm matches vanishing conﬁdence setting. main interest paper whether ideas garivier extend general settings depth non-uniform particular limited move histories lead shared states considering extensions found cleaner introduce abstract setting mentioned motivation clearly delineate crucial properties problem results use. general structured setting section prove instance dependent lower bound along lines auer garivier specialized minimax game search setting show crucial role call proof sets somewhat reminiscent so-called conspiracy sets adversarial search lower bound matches garivier case two-move alternating problems. considering abstract setting propose algorithm call lucb-micro considered natural generalization maximin-lucb garivier regularity assumption payoﬀ maps prove algorithm meets risk-requirement. also provide high-probability instance-dependent upper bound algorithm’s sample complexity discuss bound meets general characteristics existing bounds fails reproduce corresponding result garivier best authors’ knowledge comparable algorithm study best identiﬁcation full-length minimax tree search setting findtopwinner teraoka algorithm roundbased elimination based algorithm additional pruning steps come tree structure. specialize framework minimax game scenario upper bound strict improvement theirs e.g. number samples related near-optimal micro-observables next consider minimax setting first show regularity assumptions made abstract setting case. also show eﬃciently compute choices lucb-micro makes using min-max algorithm. finally strengthen previous result able reproduce mentioned result garivier identify obvious way. denote vector deﬁned p|vi|qiprds. vectors deﬁne further write write denote |b|-dimensional vector obtained restricting components index puiqipb. denote dimensional vector whose components equal one. nonempty also denote |b|-dimensional all-one vector. denote complementer indicator function denoted it¨u. minpa maxpa denotes topological closure denotes interior. given real value ´pa^ sequence values value deﬁne joinph positive integers problem instance structured k-armed best identiﬁcation instance micro-observations deﬁned tuple l-tuple distributions reals. xdpipxq denote mean distribution shall denote component functions fpµq pfpµq fkpµqq. value fipµq interpreted payoﬀ call reward map. goal learner identify highest payoﬀ. assumed highest payoﬀ unique. learner knows unaware particular unaware gain information learner query distributions discrete rounds indexed sequential fashion. learner also given risk parameter goal learner identify highest payoﬀ using least number observations keeping probability making mistake speciﬁed risk level. learner admissible given problem instances instance probability learner misidentifying optimal instance given ﬁxed risk factor learner stops probability instance interaction learner problem instance shown fig. minimax games motivating example consider problem ﬁnding optimal move ﬁrst player ﬁnite twoplayer minimax game. game ﬁnite game ﬁnishes ﬁnitely many steps ﬁrst player moves. value move function values possible terminating states. formally minimax game described nonempty ﬁnite possible moves yněm ﬁnite histories moves function t´`u determines feasible history identity player turn surjection maps subset hmax histories maximal histories element maximal preﬁx history words continuation property every preﬁx positive length also ﬁrst player’s moves given histories unit length. minimize clutter without loss generality identify rks. function underlying gives payoﬀs ﬁrst player. deﬁne auxiliary function evaluates particular history given values assigned terminal states. given deﬁne fkpµq ppkq rks. remains deﬁne hmax µτphq. feasible history pphq maxtpphqv hsuccphqu hsuccphq tjoinph muxh immediate successors thus pphq maximum values associated immediate successors pphq minimum values. deﬁne move deﬁning optimal immediate successor given note many deﬁned functions depend dependence suppressed keep ﬁxed. natural problem setting game payoﬀs terminating states game randomized explained garivier setting also shed light design better monte-carlo tree search algorithms relatively novel class search algorithms proved highly successful recent years section prove lower bound case ﬁxed instances normal distributions unit variance. denote corresponding instances snorm results easily extended case suﬃcientlyrich family distributions. next result assume without loss generality fpµq fpµq fkpµq. learner maps histories actions. simplicity assume deterministic prls sequences observable-index observation pairs itpωq ytpωq equip associated lebesgue σ-algebra inﬁnite sequence tpωq round index algorithm stops thus similarly deﬁne choice algorithm stops deﬁne jpωq case tpωq interaction problem instance learner induces unique distribution measurable space pωfq agree rounds index specify algorithm chooses observation distributions modiﬁed observation deterministically zero. also denote expectation operator corresponding pµa. appease prudent reader note statements always concerned events subsets event eﬀected specify choices algorithm responses environment take example expected number steps takes environment eµarts bound below. since bound case algorithm admissible implies pµapt eµarts eµart shows behavior outside outside immaterial statement. choices made however signiﬁcant simplify technical result. state result need introduce signiﬁcant departures contains vectors best formally proof shown reproduce result garivier kaufmann setting best identiﬁcation. proof uses standard steps main merit simplicity. particular relies information theoretical results; high-probability pinsker inequality standard decomposition divergences. proof given section signiﬁcant deparremark ﬁrst need deﬁnitions deﬁnition take minimax game structure ﬁrst moves terminal states. take rks. said suﬃcient proving upper bounds value move implies fjpµq symmetrically said suﬃcient proving lower bounds value move implies fjpµq call sets satisfying deﬁnition upper proof sets denoted proof sets closely related conspiracy sets forming basis proof number search minimax game tree conspiracy node leaves must change evaluation value cause change minimax value node proof sets also related cuts search denote histories start move consider non-empty satisﬁes following properties pphq hsuccphq pphq hsuccphq call obtained construction immediately proposition take note second inclusion shows replacing deﬁnition τ˚pµq would decrease value τ˚pµq ﬁrst inclusion shows value actually change. following lemma characterizing minimal departures essential proof proposition section propose algorithm generalizing lucb algorithm kalyanakrishnan prove theoretical guarantee proposed algorithm’s sample complexity assumptions structure reward mapping result inspired extends results garivier general setting proposed paper. section give version algorithm presented specialized minimax games reﬁne upper bound section highlighting advantages extra structure minimax games. section shall assume distributions ppiqiprls subgaussian need result anytime conﬁdence intervals martingales subgaussian increments. stating result pftqtpn ﬁltration probability space holding random variables introduce etr¨s er¨|ft´s. result appears theorem paper kaufmann also cite precursors lemma pxtqtpn pftqtpn-adapted subgaussian martingale diﬀerence sequence index round algorithm soon proposed stops xtprtsiprlstµi piqsu good event proposed respective intervals algorithm stops contain rls. easily verify that regardless choice algorithm tpiq deﬁne fpsq tfpsq deﬁnition piqs fjpµq fjpstq holds thus fjpstq valid δqlevel conﬁdence fjpµq. general sets complicated structure. hence adapt following simplifying assumption also dtpjq note assumption reward underlying minimax games second assumption could replaced following weaker assumption without essentially changing result rfjpuq fjpvqs raui rls. point assumption guaranteeing intervals micro-observables shrink interval arm-rewards also shrink rate. expect ways weakening assumption also possible perhaps price slightly changing algorithm based assumption propose algorithm lucb-micro following idea lucb lucb-micro chooses eﬀort separate highest lower bound best competing upper bound. decrease width conﬁdence intervals micro-observable chosen help assumption seen generalization choice made maximin-lucb garivier here found speciﬁc maximin-lucb’s choice made considerably obscured idea behind choice perhaps attribute fact two-move setting makes possible write choice more-or-less direct fashion. fpµq fpµq assumed fpµq fpµq maxjě fjpµq. main result using lower bound departs choice lucb would fjpˆµtq deﬁne reason departure found easier work lower bound. expect versions behave similarly. then event stopping time lucb-micro satisﬁes t˚pµq. note thus t˚pµq well-deﬁned. furthermore letting logpl{δq logpl{δq suﬃciently small hpµq suﬃciently large elementary calculations give remark constant hpµq acts hardness measure problem. theorem applied best identiﬁcation problem multi-armed bandits setting special case problem setup. compared state-of-the-art results available setting bound looser several ways lose constant factor multiplying hpµq also lose additive term hpµq logplq also lose logplq terms suboptimal arms comparing result available two-move minimax tree setting garivier bound looser theorem motivates reﬁnement result minimax setting done next section recover mentioned result garivier positive side result generally applicable mentioned results. remains interesting sequence challenges prove upper bound algorithm would match mentioned state-ofthe-art results general setting specialized. section show upper bounds number observations lucb-micro takes case minimax game problems. still assume micro-observations subgaussian optimal unique. apply result leaves showing payoﬀ function minimax game satisﬁes regularity assumption minimax game structure ﬁrst show property assumption holds. follows easily following lemma proven induction based distance terminating states. corollary fpuq fpvq hence assumption holds. property assumption need show sets nonempty. history denote length-k preﬁx give algorithmic demonstration also shows eﬃciently pick element sets. resulting algorithm called minmax deﬁne minmax recursive fashion nonmaximal history algorithm extends history adding move optimal minimizing moves extends adding optimal move maximizing moves calls history. algorithm returns input maximal history. show τpminmaxph following result lemma rks. minmaxppjqq particular then corollary previous result setting τphq rfjpvq fjpvqs viqs hence this shown assumptions needed theorem satisﬁed call particular minmaxpbt resulting algorithm lucbminmax. then theorem gives corollary hpµq section stopping time lucbminmax running minimax game search problem applied minimax game deﬁned section upper bound corollary loose improved shown result below. state result need notation. given reals deﬁne span spanpsq maxuvps path connects move move rls. finally unique path satisfying τphq deﬁne empty multiple τphq remark note result recovers theorem garivier note every leaf vppi also note thus µij| maxt|c µi||µij µi|u. therefore spanptµi maxt|µi c||µij µi|u. lower bound upper bound substantial lower upper bound. besides gaps already exist multiarmed bandit setting mentioned before exists substantial particular hard show regular minimax game trees ﬁxed branching factor depth upper bound scales opκdq lower bound scales opκd{q. potential improve lower bound consider adversarial perturbations values assigned leaf nodes algorithm ﬁxed adversary perturb values maximize lower bound. simchowitz introduces interesting technique proving lower bounds form demonstrate nontrivial improvements multi-armed bandit setting. algorithm need explore leaves? hardness measure hpµq rooted uniform bound suggests leaves must potentially pulled hold particular structure. particular algorithm able beneﬁt speciﬁc structure saving explorations leaves. present example minimax game tree figure assume reasonable algorithm would sample once discover others arms much less sampled leaf algorithm continue explore leaves decide best arm. behavior also agreement lower bound resulting constraints large enough. implies example pk´q leaves need exploration all. hand although don’t tight upper bound algorithm practice manages explore remaining leaves next rounds make right decision. general would expect problem feed forward neural network structure easier tree structure share leaves provides information thus save exploration. illustrated fig. optimal identiﬁed solely based network structure thus algorithm requires sample possible note lower bound fail here. recall throughout paper deﬁnition following assumption assumption instance j˚pµq argmaxj fjpµq unique. state assumption explicitly here refer easily throughout appendix. start information theoretic results mentioned main body text. state results denote kullback–leibler divergence dqqdq absolutely continuous distributions recall itit denote respect inﬁnite otherwise. next result npiq number times observation micro-observable index time right-hand side divergence normal distributions means unit variance. result naturally holds distributions well. result relies strongly forced observations observation-choices particular makes left-hand side ﬁnite proof standard hence omitted. construct pick τprh hmaxq τprhj hmaxq. construction pick suﬃces specify unique successor history pphq this suﬃces specify unique successor history pphq proof uses induction based length histories take length unique immediate predecessor pphq then deﬁnition induction claim exists hmax hmax fpµ` history length deﬁnition fpµ` assume statement holds histories length hsuccphq. well-deﬁned thanks deﬁnition construction hypothesis implying hand pphq fpµ` maxtv hsuccphqu ﬁnishing induction. hence proven construct sequential process. this choose sequence moves nutshell sequence optimal sequence moves starts move also known principal variation game move details construction follows start choose ppmq fpµ` deﬁnition assume already chose holds. hmax done. otherwise µ`dq thus pjoinph mi`q fpµq. further construction recap proved entirely analogous proof shows also fjpµ mintpµ prove fpµ`dq fjpµ`dq ﬁnishing proof assume contrary fpµ` fjpµ` consider fpµ` αdq´ fjpµ` interval note continuous gpq. hence intermediate value theorem exists gpαq note fjpµ αdq. hence since α|d| dmin cannot hold contradiction. hence fpµ`dq fjpµ turn proof prove holds bzb. proof assume contrary desired statement exists thus corollary fjpµ mintpµ mintpµ fjpµ last equality last inequality follows lemma implies together contradicts dmin remains prove pick since fjpµ already established suﬃces show either maxkpbpµ fjpµ minkpbpµ showing fjpµ hence assume done. otherwise maxkpbpµ dqi. note ´pdi \u0001q´. shifted deﬁne towards zero positive amount never crosses zero. then |d|. note minpdi maxkpbpµ dqk. also hence maxkpbpµ` maxkpbpµ` fpµ` thus lemma fpµ` fpµ`dq. fpµ`dq fjpµ`dq minkpbpµ`dqk. deﬁnition maxkpbpµ`dq lemma minkpbpµ minkpbpµ fjpµ putting together inequalities fjpµ hence however contradict dmin then fjpµq mint fjpµqu rks. proof rks. prove mintθ induction based close history maximal history. note suﬃces prove statement thanks fjpµq ppjq mintθ ppjq mintθ fjpµqu. deﬁne function cphq hmax cphq maxtcphq hsuccphqu mintθ mintθ holds hsuccphq mintv hsuccphqu thus mintθ mintθ mintv hsuccphquu. this ready prove proposition repeat reader’s convenience proposition assume wlog fpµq maxją fjpµq. |d|; fpµq; fpµq. altogether contradict dmin show note fpµq fpµq |di|. therefore proving note fpµq. lemma also maxpb previous inequality implies lemma fpµq showing rfpµq fpµqs. combining previous statements leads conclusion dmin deﬁnition wlog assume suﬃces show fpµq fpµq show fpµq leaving proof relationship reader start correctness result proposition event lucb-micro returns correctly j˚pµq. proof assume contrary j˚pµq. wlog j˚pµq assumption deﬁnition stopping rule fjpµq fjplδ lemma then exists rfjplδ fjpu proof ﬁrst prove yjptbtcturfjplδ this suﬃces show hold complementer holds least four conditions hold fbtplδ fctplδ fbtpu fctpu case implies payoﬀ contradicts deﬁnition case fctplδ contradicts deﬁnition case true deﬁnition algorithm stopped hence thus cannot hold hence rfjplδ proving ﬁrst part. next note fjpµq| also fjpµq| fjpu fjpµq| prove theorem proof prove result induction based close history maximal history. earlier proof cphq hmax otherwise cphq maxtcphq hsuccphqu recall hsuccphq denotes immediate successors pitqs. otherwise multiple path τphq vpit unique path. since pulled minmaxpmq note lemma implies thus phk` suﬃcient prove however follows lemma event spiq µqytc µiu. result lemma piqs implies", "year": 2017}