{"title": "Many-to-Many Graph Matching: a Continuous Relaxation Approach", "tag": ["stat.ML", "cs.CV"], "abstract": "Graphs provide an efficient tool for object representation in various computer vision applications. Once graph-based representations are constructed, an important question is how to compare graphs. This problem is often formulated as a graph matching problem where one seeks a mapping between vertices of two graphs which optimally aligns their structure. In the classical formulation of graph matching, only one-to-one correspondences between vertices are considered. However, in many applications, graphs cannot be matched perfectly and it is more interesting to consider many-to-many correspondences where clusters of vertices in one graph are matched to clusters of vertices in the other graph. In this paper, we formulate the many-to-many graph matching problem as a discrete optimization problem and propose an approximate algorithm based on a continuous relaxation of the combinatorial problem. We compare our method with other existing methods on several benchmark computer vision datasets.", "text": "graphs provide efﬁcient tool object representation various computer vision applications. graph-based representations constructed important question compare graphs. problem often formulated graph matching problem seeks mapping vertices graphs optimally aligns structure. classical formulation graph matching one-to-one correspondences vertices considered. however many applications graphs cannot matched perfectly interesting consider many-to-many correspondences clusters vertices graph matched clusters vertices graph. paper formulate many-to-many graph matching problem discrete optimization problem propose approximate algorithm based continuous relaxation combinatorial problem. compare method existing methods several benchmark computer vision datasets. represented segmentation contours shock graph interest points graph representation chosen fundamental question often arises comparing graphs order compare images objects. particular important many applications assess quantitatively similarity graphs detect similar parts graphs graph matching approach perform tasks. graph matching tries align graphs matching vertices edges conserved across matched vertices. graph matching useful assess similarity graphs capture similar parts graphs graph matching framework many applications computer vision e.g. match shapes match deformable objects methods based linear projective transforms usually fail classically one-to-one mappings considered graph matching. words vertex ﬁrst graph matched vertex second graph vice-versa. problem formulated discrete optimization problem wishes one-to-one matching maximizes number conserved edges alignment. problem np-hard general graphs remains impossible solve exactly practice graphs vertices therefore much effort devoted development approximate methods able good solution reasonable time. methods roughly divided large classes. ﬁrst group consists various local optimization algorithms permutation matrices including a∗-beam-search genetic algorithms.the second group consists solving continuous relaxation discrete optimization problem ℓ-relaxation path algorithm various spectral relaxations power methods practice sometimes confronted situations notion one-to-one mapping restrictive would like allow possibility match groups vertices ﬁrst graph groups vertices second graph. call mapping many-to-many. instance computer vision parts object represented different numbers vertices depending noise image choice object view could relevant match together groups vertices represent part. algorithmic point view problem much less investigated one-to-one matching problem. one-to-one matching methods based local optimization permutation matrices extended many-to-many matching e.g. considering possibility merge vertices edges course optimization spectral methods also extended deal many-to-many matching combining idea spectral decomposition graph adjacency matrices clustering methods however spectral approach one-to-one matching interpreted particular continuous relaxation discrete optimization problem interpretation lost extension many-to-many matching. fact aware proper formulation many-to-many graph matching problem optimization problem solved relaxation techniques. main contribution propose formulation many-to-many graph matching problem discrete optimization problem generalizes usual formulation one-to-one graph matching present approximate method based continuous relaxation problem relaxed problem convex solve approximately conditional gradient method. also study different ways back continuous solution relaxed problem many-to-many matching. present experimental evidence section simulated simple real data formulation provides signiﬁcant advantage one-to-one many-to-many matching approaches. section derive formulation many-to-many graph matching problem discrete optimization problem. start recalling classical expression one-to-one matching problem optimization problem. show extend one-to-one formulation case one-to-many matchings. finally describe deﬁne many-to-many matchings many-to-one mappings. one-to-one graph matching. graphs vertices note twice number edges conserved matching deﬁned permutation one-to-one graph matching problem therefore classically expressed following discrete optimization problem denotes constant n-dimensional vector ones. note poto simply represents permutation matrices. convex hull doubly stochastic matrices constraint replaced one-to-one one-to-many. suppose less vertices goal matching associates vertex vertices vertex matched vertex call matching one-to-many problem ﬁnding optimal one-to-many matching formulated minimizing criterion modifying optimization follows denotes size graph denotes size graph kmax denotes optional upper bound number vertices matched single vertex. opposed one-to-one matching case allowed larger non-zero elements i-th corresponds vertices graph matched i-th vertex existing continuous relaxation techniques adopted oneto-many matching. example describes spectral relaxation methods used case one-to-many matching. techniques like convex relaxation used well since convex hull potm also obtained relaxing constraint one-to-many many-to-many. match graphs under many-to-many constraints proceed matched graphs virtual graph many-to-one constraints minimizing difference transformed graph obtained transformed graph obtained idea many-to-many matching double one-to-many matching illustrated figure graph represents graph matched vertex clusters. vertex corresponds group vertices group vertices matched other. pmto denote many-to-one matching pmto many-to matching propose formulate many-to-many graph matching problem optimization problem seek minimize difference intermediate graph squeezed considering directly difference following objective function many-to-many graph matching problem pmto pmto denote many-to-one mappings. objective function similar objective function oneto-one case seek permutation makes second graph similar possible seek combinations merges permutations makes similar possible other. difference formulations many-to-many case merging operation. slightly different ways deﬁning matrices minimized. advance number matching clusters corresponds size case optimization pmto pmto. alternative follow paper remove constraint deﬁnition pmto case method estimates number matching clusters finally thus formulate many-to-many graph matching problem follows represents maximal number matching clusters. formulation fact valid many kinds graphs particular graphs directed edge weights self-loops also describe section formulation modiﬁed include information vertex labels important computer vision many-to-many graph matching problem hard discrete optimization problem. therefore need approximate method solve practice. section propose algorithm based continuous relaxation purpose propose replace binary constraints continuous constraints note linear objective function continuous relaxation would exact simply replace optimization convex hull. however objective function quartic optimum general extreme point optimization set. solve relaxed optimization problem propose following version conditional gradient minimization linear function step i.e. minp version linear semi-assignment problem reduces classical linear assignment problem adding dummy nodes. solve linear assignment problem kmax matrix done efﬁciently hungarian algorithm solution line search step found closed form since objective function polynomial fourth order. conditional descent algorithm converges stationary point non-convex nature objective function hope reach local minimum important good initialization. experiments found good choice ﬁxed uniform initialization initialize identity matrix another option would convex relaxation one-to-one matching algorithm complexity mainly deﬁned parameters kmax condition number hessian matrix describing objective function near local minima direct inﬂuence number iterations deﬁnes cost iteration i.e. complexity hungarian algorithm projection. reached local optimum relaxed optimization problem still need project matrices values rather several alternatives considered. ﬁrst idea columns deﬁne similarity measure vertices graphs e.g. computing products columns. indeed similar columns corresponding vertices likely vertices matched different graphs merged graph. therefore ﬁrst strategy clustering algorithm column vectors concatenated matrix resulting clustering construct ﬁnal manyto-many graph matching. alternative clustering incremental projection forward selection projection uses matching objective function every step. obtained continuous relaxation take pair vertices union graphs similar column vectors re-run continuous relaxation constraint vertices remain matched. similar pair vertices constrained continuous solution. greedy scheme iterated vertices matched. experiments second approach produced better results. mainly fact clustering algorithm objective function incremental projection adapt column vectors unmatched vertices according earlier established matchings. neighbor merging. many cases interesting favor merging neighboring vertices opposed merging sets vertices. propose following modiﬁcation matrix product matrix entry equal merged cluster. therefore components objective function represent number pairs adjacent vertices merged together respectively. local similarities. like one-to-one formulation easily modify many-to-many graph matching formulation include information vertex pairwise similarities modifying objective function follows matrix rng×nh matrix local dissimilarities graph vertices parameter controls relative impact information graph vertices information graph structures. objective function polynomial fourth order algorithm still used directly without additional modiﬁcations. exist major groups methods many-to-many graph matching brieﬂy describe section. ﬁrst consists local search algorithms generally used context graph edit distance second composed variants spectral approach. local search algorithms. examples kind approach given classical formulation graph edit distance graph edit operations consists deletion insertion substitution vertices edges. operation associated cost objective sequence operations lowest total cost transforming graph another. case many-to-many graph matching operations completed merging operations. since estimation optimal sequence hard combinatorial problem approximate methods beam search well examples best-ﬁrst breadth-ﬁrst depth-ﬁrst searches used. spectral approach. caelli kosinov discuss spectral matching used many-to-many graph matching. algorithm similar umeyama method instead one-to-one correspondences search many-to-many mapping running clustering algorithm. ﬁrst step spectral decomposition graph adjacency matrices considered rows eigenvector matrices interpreted spectral coordinates graph vertices. vertices similar spectral coordinates clustered together clustering algorithm vertices grouped cluster considered matched. another example spectral approach given where roughly speaking adjacency matrix replaced matrix shortest path distances spectral decomposition clustering used. section compare method proposed paper existing techniques thus test three competitive approaches several experiments beam-search beam generate random graph size edge present probability build randomly permuted copy randomly split vertices taking random vertex split vertices introduce noise adding/deleting random edges graphs. already mentioned principal interest understand behavior graph matching algorithms function graph size ability resist structural noise. indeed practice never identical graphs important robust algorithm able deal noise graph structures. objective function represents quality graph matching compare different graph matching algorithms plot function function three algorithms. cases observe grad signiﬁcantly outperforms beam spec. beam beam width equal represents good trade-off quality complexity spec projection ﬁrst eigenvectors normalization presented figure shows algorithms scale time graph size spec algorithm fastest grad complexity order spec curves coherent theoretical values algorithm complexity summarized section beam algorithm much slower also worse complexity order. figure function graph size simulation parameters function noise parameter simulation parameters algorithm running time function parameters beam slope grad slope spec slope compute similarity/distance objects interest basis graph-based representations. classiﬁcation problem chose etlb dataset chinese characters. dataset well suited purposes since chinese characters naturally represented graphs variable nontrivial structures. figure illustrates grad works graphs representing chinese characters. algorithm produces good matching although perfect providing correspondence crucial vertices. characters represented figure however easy recognize classiﬁcation algorithms show good performance them; example grad produces classiﬁcation error rate test graph matching algorithms challenging situations chose three hard classify chinese characters i.e. three characters sharing similar graph structures illustrated table k-nearest neighbor graph matching algorithms used distance measures. dataset consists images images class. table shows classiﬁcation results three many-to-many graph matching algorithms. addition report results popular approaches namely classiﬁer linear gaussian kernels one-to-one matching path algorithm versions shape context method without thin plate spline smoothing. version named shape context computes polar histograms bipartite graph matching. shape context+tps method used code available online. graph matching algorithms using information vertex coordinates elements matrix deﬁned e−−. parameter well learned cross-validation. grad algorithm shows best performance outperforming many-to-many graph matching algorithms well competitive approaches. advantage graph-based image alignment algorithms used problems deformable objects. figure shows grad algorithm aligns pair photos spiders photos taken completely different viewpoints signiﬁcant difﬁculty many existing image alignment approaches based grouping superpixels methods generate various rotations linear transforms image take best alignment approaches possible deformations. since image alignment rotation invariant explicit vertex coordinates construct matrix done previous section. instead shape context features namely vertex gets feature vector representing polar histogram vectors joining vertex graph vertices. make polar histogram rotation invariant align polar histograms taking origin angle direction center mass graph vertices. setup polar histograms invariant respect rotations around graph center mass. figure grad ﬁgures ﬁrst image corresponds bottom second image example groups vertices representing left part second spider head matches vertex left graph representing part ﬁrst spider figure illustration rotation invariant matching made grad. original spider photos corresponding graph-based representations given left. right spider graphs aligned grad. vertices id’s matched other. pattern recognition framework interesting important comparison different graph matching algorithms evaluates aspect algorithms namely ability detect similar graphs. second important aspect ability correctly align vertices corresponding parts objects. test capability performed following series experiments. chose camel images mpeg dataset divided hand image parts head neck legs back tail body image segmentation automatically deﬁnes partitioning corresponding graph shown column figure graph vertices labeled according image part represent. figure gives illustrations procedure works. good graph matching algorithm vertices corresponding image parts other i.e. heads heads legs legs therefore evaluate matching quality mapping following score. first match graphs predict vertex labels graph given vertex labels second one. instance vertex ﬁrst image matched vertices representing head second image predict class head. better graph matching smaller prediction error vice-versa. figure original images. manual segmentation graph-based representation induced vertex labels prediction vertex labels basis graph matching made grad. best seen color. rithms. usually segmentation algorithms extract image parts basis different characteristics changing color narrowing object form etc. graph matching algorithm extract segments speciﬁc appearance also semantic interpretation deﬁned user table presents mean prediction error pairs camel images pair associated scores prediction error ﬁrst image given second vice-versa. thus scores algorithm used compute means standard deviations. like previous sections graph matching algorithms using information vertex coordinates e−−. parameter well learned cross-validation. here observe grad algorithm works better methods. main contribution paper formulation many-to-many graph matching problem discrete optimization problem approximate algorithm grad based continuous relaxation. success proposed method compared competitive approaches explained reasons. first methods based continuous relaxations discrete optimization problems often show better performance local search algorithm ability better explore optimization potentially large moves. second grad algorithm aims optimize clear objective function naturally representing quality graph matching instead sequence unrelated steps. ject alignment. however structural noise usually encountered graph-based representations slightly hampered application natural images; believe many-to-many graph matching framework presented paper provide appropriate notion robustness necessary computer vision applications. course requires validation approach graphs obtained cluttered images currently experimenting with.", "year": 2010}