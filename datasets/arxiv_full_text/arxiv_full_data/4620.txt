{"title": "A Time and Space Efficient Junction Tree Architecture", "tag": ["cs.AI", "cs.LG"], "abstract": "The junction tree algorithm is a way of computing marginals of boolean multivariate probability distributions that factorise over sets of random variables. The junction tree algorithm first constructs a tree called a junction tree who's vertices are sets of random variables. The algorithm then performs a generalised version of belief propagation on the junction tree. The Shafer-Shenoy and Hugin architectures are two ways to perform this belief propagation that tradeoff time and space complexities in different ways: Hugin propagation is at least as fast as Shafer-Shenoy propagation and in the cases that we have large vertices of high degree is significantly faster. However, this speed increase comes at the cost of an increased space complexity. This paper first introduces a simple novel architecture, ARCH-1, which has the best of both worlds: the speed of Hugin propagation and the low space requirements of Shafer-Shenoy propagation. A more complicated novel architecture, ARCH-2, is then introduced which has, up to a factor only linear in the maximum cardinality of any vertex, time and space complexities at least as good as ARCH-1 and in the cases that we have large vertices of high degree is significantly faster than ARCH-1.", "text": "junction tree algorithm computing marginals boolean multivariate probability distributions factorise sets random variables. junction tree algorithm ﬁrst constructs tree called junction tree who’s vertices sets random variables. algorithm performs generalised version belief propagation junction tree. shafer-shenoy hugin architectures ways perform belief propagation tradeoﬀ time space complexities diﬀerent ways hugin propagation least fast shafer-shenoy propagation cases large vertices high degree signiﬁcantly faster. however speed increase comes cost increased space complexity. paper ﬁrst introduces simple novel architecture arch- best worlds speed hugin propagation space requirements shafer-shenoy propagation. complicated novel architecture arch- introduced factor linear maximum cardinality vertex time space complexities least good arch- cases large vertices high degree signiﬁcantly faster arch-. junction tree algorithm popular tool simultaneous computation marginals multivariate probability distribution stored factored form. paper consider case random variables boolean. junction tree algorithm generalisation belief propagation performed tree who’s vertices sets random variables. shafer-shenoy hugin architectures variations junction tree algorithm trade time space complexities diﬀerent ways hugin propagation faster shafer-shenoy propagation cost greater space complexity. large vertices high degree cause much ineﬃciency architectures purpose paper introduce novel architectures perform better cases. order tackle problem high-degree vertices algorithm given constructing binary junction tree shafer-shenoy propagation performed. method shown empirically faster hugin propagation drawback method however require dramatically space shafer-sheony propagation generic junction tree maximum cardinality intersection neighbouring vertices large. also noted architecture given eliminated redundant computations shafer-shenoy propagation. though architecture dramatically increased space complexity shafer-shenoy propagation. comparison architectures introduced paper tackle problem high degree vertices whilst retaining space complexity shafer-shenoy propagation novel architectures introduced paper ﬁrst arch- achieves speed hugin propagation space requirements shafer-shenoy propagation. arch- simple serves warm complicated architecture arch- space time complexities least good arch- cases large vertices high degree signiﬁcantly faster arch-/hugin. cases large enough vertex who’s degree exponential cardinality arch- polynomial saving time complexity arch-/hugin i.e. exists time becomes time saving time complexity going shafer-shenoy hugin/arch- similar. detailed description results paper given section preliminary deﬁnitions introduced junction tree algorithm described. paper assume basic operations arithmetic operations memory reads/writes take constant time. ease reader’s understanding algorithms given sections though sketches achieve stated time complexities must able store variables constant amortised time space. exact implementations give stated time space complexities given section paper structured follows section give preliminary deﬁnitions required paper. section give overview junction tree algorithm detailed overview results paper technicalities relating time/space complexities. section describe shafer-shenoy hugin architectures analyse complexities. section describe architecture arch- analyse complexity. section describe architecture arch- analyse complexity. section describe modify arch- deal zeros. section give details implement algorithms introduced paper. section deﬁne notation concepts used paper except required exclusively implementation details algorithms deﬁned section also notation mh→c well notion sending receiving messages deﬁned algorithm deﬁne pseudo-code used paper left arrow denotes assignment e.g. indicates value computed assigned variable function names written bold input coming brackets name. assignment symbol function right hand side indicates function output function assigned variable left hand side e.g. function indicates function function input output assigned variable word return appears pseudo-code function indicates function terminates outputs note potential equivalent possible binary labellings positive reals equivalence seen noting bijecitive mapping possible binary labellings subset maps labelling given operations paper easier describe domain potential power-set deﬁne potentials way. given tree deﬁne vertex edge respectively. also given tree vertex deﬁne degree neighbourhood respectively. tree rooted deﬁne vertex parent children respectively. junction tree algorithm simultaneously computing potentials every algorithm three stages junction tree construction stage message passing stage computation marginals stage paper consider detail message passing stage junction tree algorithm ﬁrst review shafer-shenoy hugin architectures diﬀer messages computed. shafer-shenoy propagation vertex contributes time large vertices high degree hugin propagation hence signiﬁcantly faster shafer-shenoy propagation. however speed increase comes cost higher space complexity whilst space complexity shafer-shenoy propagation required store factors messages hugin architecture must store every vertex potential meaning space required exponential width junction tree. describe merger ideas behind shafer-shenoy hugin propagation simple novel architecture arch- best worlds speed hugin propagation space complexity shafer-shenoy propagation. main idea behind arch- simultaneously computing many marginals factored potential leads novel architecture arch- least time space eﬃciency arch- considerably faster large vertices high degree. speciﬁcally vertex contributes time note that although don’t explicitly describe computation marginals stage ideas behind arch- used stage time space greater message passing stage arch- details left reader. stated introduction ease reader’s understanding algorithms given sections though sketches achieve stated time complexities must able store variables constant amortised time space. exact implementations give stated time space complexities given section also note auxiliary space required algorithms paper additive factor stated since must maintain array size however since greater space required store factors neglect this. potential must compute requires auxiliary space θ|c| leading space requirement least ωmaxh∈v operation time θk|c| uses constant auxiliary space algorithm used performing operation computation message mc→e takes time |)|c|) requires constant auxiliary space. hence space complexity entire message passing algorithm space required store factors messages. since vertex sends messages vertex contributes time entire message passing algorithm. note time required vertex pass message neighbour since vertex sends receives message to/from neighbours since potential takes time θ||c|) initialise contributes time |)|c|) entire message passing algorithm. note hugin propagation faster shafer-shenoy propagation. drawback however storing vertex potential number associated factors combining factors binary basis speed time constant factor. addition faster version hugin propagation still never faster arch- logarithmic factor large vertices high degree still signiﬁcantly slower arch-. section describe architecture arch- speed hugin propagation space complexity shafer-shenoy propagation. reason time/space complexity many marginals computed simultaneously factored potential using merger ideas behind shafer-shenoy hugin propagation algorithm similar algorithm division idea hugin architecture. like shafer-shenoy propagation store messages. arch- selects vertex root phases inward phase messages passed tree root outward phase messages passed tree root leaves. ﬁrst sketch outline arch- going details consider next outward phase prove induction root leaves mc→e correctly computed inductive hypothesis result mh→c correctly computed every mh→c correctly computed note that every vertex operation called twice time taking time algorithm |)|c|). vertex hence contributes time θ+|f |)|c|) time complexity whole message passing algorithm. arch- hence time complexity hugin propagation. like shafer-shenoy propagation space required arch- required store factors messages. describe architecture arch-. time space complexities arch- always least good arch-. cases large vertices high degree arch- signiﬁcantly faster arch-/hugin. arch- proceeds similarly arch- using operation steps algorithm diﬀerence arch- arch- operation computed. algorithm performing operation based upon concepts p-dual m-dual potential. ﬁrst give deﬁnition duals required theory surrounding them. subsection introduce m-dual required theory surrounding m-dual deﬁned name inclusion-exclusion format used diﬀerent way. ﬁrst deﬁne m-dual potential describe functions used arch-. functions transform transforms potential p-dual product computes product potentials working p-duals transform transforms p-dual potential m-dual potential marginalise computes marginals potential summarise algorithm following first potentials converted p-duals. p-duals p-dual product potentials computed stored sparse format. potential sparse format m-dual computed used compute m-duals di-marginals m-duals converted potentials call time complexity computation time note every vertex contributes computation time time computation time time computation time vertex. vertex hence contributes total time running time arch-. addition equation |di|. hence equation step algorithm functions o|c|sk require auxiliary space o|c|ph∈n |h∩c| +pλ∈f imomaxc∈v |c|ph∈n |h∩c| +pλ∈f |σ|. hence space requirement zeros incorporated arch- follows running algorithm numbers converted reals numbers numbers. lines algorithm numbers instead reals. line complete numbers coverted numbers real numbers. lines algorithm using real numbers. section assume without loss generality throughout entire junction tree algorithm maintain array size element internal vertices trees. note pseudo-code regard element vertices rather pointer pointers vertices. denote e-th element also maintain leaves trees. like shall pseudo-code regard leaves rather pointers leaves. used synchronised-searches full-searches label labels given internal vertices child bijection leaves that leaf given straddle-tree also refer tree based note since straddle-tree full binary tree leaves vertices total. note also straddle-tree balanced oriented binary tree height internal vertices depth labeled smallest number section describe ways algorithms perform eﬃcient simultaneous searches straddle-trees. types simultaneous search describe full-searches used arch- synchronised-searches used arch-. start deﬁning ghost-search simultaneous searches based ghost-search given ghost-search following algorithm split sequence steps called time-steps maintain stack element either form initialised contain single element. time-step following element remove completes time-step. else element following cases time-steps stack corresponds times depth ﬁrst search internal vertex time encountered throughout depth ﬁrst search. leaf-steps correspond times depth-ﬁrst search leaves hence bijection correspondence leaf-steps sets full-search given multi-set straddle-trees full-search following algorithm ﬁrst deﬁne labels internal vertices trees note found ordered quickly. note running synchronised-search empty array empty every element roots trees initialise every adding initialisation perform ghost search stack ghost search. every time-step ghost search following full-search essentially following recall given correspondence leaf-steps sets suppose leaf-step. corresponding leaf-step. start leaf-step equal leaves trees that given leaf syncronised-search given multi-set straddle-trees synchronised-search following algorithm ﬁrst deﬁne labels internal vertices trees note found ordered quickly. note running synchronised-search empty array empty every element roots trees initialise every adding initialisation perform ghost search stack ghost search. every time-step ghost search following nk}. leaf start t-th leaf-step full-search. full-search addition maintaining variable also maintain variable well every variable start ﬁrst leaf step following first deﬁne root note straddle-tree underlying copy tree synchronised-search start every leaf-step following doesn’t contain leaf nothing. else cases steps algorithm performed together follows first root synchronised search start every leaf-step following doesn’t contain leaf nothing. otherwise leaf leaf leaf cases synchronised searches active vertex. also every point algorithm active vertex either left-oriented right-oriented. initialise vertex active vertex left-oriented. initialisation synchronised-search nk}. stack used synchronised search. start every time-step ﬁrst following element following nothing. otherwise given active vertex currently currently left-oriented vertex make active vertex designate left-oriented. paper reviewed classic architectures shafer-shenoy hugin propagation introduced junction tree architectures ﬁrst arch- speed hugin propagation space requirements shafer-shenoy propagation. second arch- space time complexities least good arch- signiﬁcantly faster large vertices high degree junction tree. ﬁrst gave high-level overview architectures details eﬃcient implementations.", "year": 2013}